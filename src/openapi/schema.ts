/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v2/oauth-clients/{clientId}/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all managed users */
        get: operations["OAuthClientUsersController_getManagedUsers"];
        put?: never;
        /** Create a managed user */
        post: operations["OAuthClientUsersController_createUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/oauth-clients/{clientId}/users/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a managed user */
        get: operations["OAuthClientUsersController_getUserById"];
        put?: never;
        post?: never;
        /** Delete a managed user */
        delete: operations["OAuthClientUsersController_deleteUser"];
        options?: never;
        head?: never;
        /** Update a managed user */
        patch: operations["OAuthClientUsersController_updateUser"];
        trace?: never;
    };
    "/v2/oauth-clients/{clientId}/users/{userId}/force-refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Force refresh tokens
         * @description If you have lost managed user access or refresh token, then you can get new ones by using OAuth credentials. Access token is valid for 60 minutes and refresh token for 1 year. Make sure to store them in your database, for example, in your User database model `calAccessToken` and `calRefreshToken` fields.
         *     Response also contains `accessTokenExpiresAt` and `refreshTokenExpiresAt` fields, but if you decode the jwt token the payload will contain `clientId` (OAuth client ID), `ownerId` (user to whom token belongs ID), `iat` (issued at time) and `expiresAt` (when does the token expire) fields.
         */
        post: operations["OAuthClientUsersController_forceRefresh"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/oauth/{clientId}/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh managed user tokens
         * @description If managed user access token is expired then get a new one using this endpoint - it will also refresh the refresh token, because we use
         *         "refresh token rotation" mechanism. Access token is valid for 60 minutes and refresh token for 1 year. Make sure to store them in your database, for example, in your User database model `calAccessToken` and `calRefreshToken` fields.
         *     Response also contains `accessTokenExpiresAt` and `refreshTokenExpiresAt` fields, but if you decode the jwt token the payload will contain `clientId` (OAuth client ID), `ownerId` (user to whom token belongs ID), `iat` (issued at time) and `expiresAt` (when does the token expire) fields.
         */
        post: operations["OAuthFlowController_refreshTokens"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/oauth-clients/{clientId}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all webhooks */
        get: operations["OAuthClientWebhooksController_getOAuthClientWebhooks"];
        put?: never;
        /** Create a webhook */
        post: operations["OAuthClientWebhooksController_createOAuthClientWebhook"];
        /** Delete all webhooks */
        delete: operations["OAuthClientWebhooksController_deleteAllOAuthClientWebhooks"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/oauth-clients/{clientId}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a webhook */
        get: operations["OAuthClientWebhooksController_getOAuthClientWebhook"];
        put?: never;
        post?: never;
        /** Delete a webhook */
        delete: operations["OAuthClientWebhooksController_deleteOAuthClientWebhook"];
        options?: never;
        head?: never;
        /** Update a webhook */
        patch: operations["OAuthClientWebhooksController_updateOAuthClientWebhook"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all attributes */
        get: operations["OrganizationsAttributesController_getOrganizationAttributes"];
        put?: never;
        /** Create an attribute */
        post: operations["OrganizationsAttributesController_createOrganizationAttribute"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/{attributeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an attribute */
        get: operations["OrganizationsAttributesController_getOrganizationAttribute"];
        put?: never;
        post?: never;
        /** Delete an attribute */
        delete: operations["OrganizationsAttributesController_deleteOrganizationAttribute"];
        options?: never;
        head?: never;
        /** Update an attribute */
        patch: operations["OrganizationsAttributesController_updateOrganizationAttribute"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/{attributeId}/options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all attribute options */
        get: operations["OrganizationsAttributesOptionsController_getOrganizationAttributeOptions"];
        put?: never;
        /** Create an attribute option */
        post: operations["OrganizationsAttributesOptionsController_createOrganizationAttributeOption"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/{attributeId}/options/{optionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete an attribute option */
        delete: operations["OrganizationsAttributesOptionsController_deleteOrganizationAttributeOption"];
        options?: never;
        head?: never;
        /** Update an attribute option */
        patch: operations["OrganizationsAttributesOptionsController_updateOrganizationAttributeOption"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/{attributeId}/options/assigned": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all assigned attribute options by attribute ID */
        get: operations["OrganizationsAttributesOptionsController_getOrganizationAttributeAssignedOptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/slugs/{attributeSlug}/options/assigned": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all assigned attribute options by attribute slug */
        get: operations["OrganizationsAttributesOptionsController_getOrganizationAttributeAssignedOptionsBySlug"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/options/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all attribute options for a user */
        get: operations["OrganizationsAttributesOptionsController_getOrganizationAttributeOptionsForUser"];
        put?: never;
        /** Assign an attribute to a user */
        post: operations["OrganizationsAttributesOptionsController_assignOrganizationAttributeOptionToUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/attributes/options/{userId}/{attributeOptionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Unassign an attribute from a user */
        delete: operations["OrganizationsAttributesOptionsController_unassignOrganizationAttributeOptionFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization bookings */
        get: operations["OrganizationsBookingsController_getAllOrgTeamBookings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/delegation-credentials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Save delegation credentials for your organization */
        post: operations["OrganizationsDelegationCredentialController_createDelegationCredential"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/delegation-credentials/{credentialId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update delegation credentials of your organization */
        patch: operations["OrganizationsDelegationCredentialController_updateDelegationCredential"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all memberships */
        get: operations["OrganizationsMembershipsController_getAllMemberships"];
        put?: never;
        /** Create a membership */
        post: operations["OrganizationsMembershipsController_createMembership"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/memberships/{membershipId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a membership */
        get: operations["OrganizationsMembershipsController_getOrgMembership"];
        put?: never;
        post?: never;
        /** Delete a membership */
        delete: operations["OrganizationsMembershipsController_deleteMembership"];
        options?: never;
        head?: never;
        /** Update a membership */
        patch: operations["OrganizationsMembershipsController_updateMembership"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/routing-forms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization routing forms */
        get: operations["OrganizationsRoutingFormsController_getOrganizationRoutingForms"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/routing-forms/{routingFormId}/responses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get routing form responses */
        get: operations["OrganizationsRoutingFormsResponsesController_getRoutingFormResponses"];
        put?: never;
        /** Create routing form response and get available slots */
        post: operations["OrganizationsRoutingFormsResponsesController_createRoutingFormResponse"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/routing-forms/{routingFormId}/responses/{responseId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update routing form response */
        patch: operations["OrganizationsRoutingFormsResponsesController_updateRoutingFormResponse"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all schedules */
        get: operations["OrganizationsSchedulesController_getOrganizationSchedules"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all teams */
        get: operations["OrganizationsTeamsController_getAllTeams"];
        put?: never;
        /** Create a team */
        post: operations["OrganizationsTeamsController_createTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get teams membership for user */
        get: operations["OrganizationsTeamsController_getMyTeams"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a team */
        get: operations["OrganizationsTeamsController_getTeam"];
        put?: never;
        post?: never;
        /** Delete a team */
        delete: operations["OrganizationsTeamsController_deleteTeam"];
        options?: never;
        head?: never;
        /** Update a team */
        patch: operations["OrganizationsTeamsController_updateTeam"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization team bookings */
        get: operations["OrganizationsTeamsBookingsController_getAllOrgTeamBookings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/bookings/{bookingUid}/references": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get booking references */
        get: operations["OrganizationsTeamsBookingsController_getBookingReferences"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/{app}/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Connect your conferencing application to a team */
        post: operations["OrganizationsConferencingController_connectTeamApp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/{app}/oauth/auth-url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get OAuth conferencing app's auth URL for a team */
        get: operations["OrganizationsConferencingController_getTeamOAuthUrl"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List team conferencing applications */
        get: operations["OrganizationsConferencingController_listTeamConferencingApps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/{app}/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set team default conferencing application */
        post: operations["OrganizationsConferencingController_setTeamDefaultApp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get team default conferencing application */
        get: operations["OrganizationsConferencingController_getTeamDefaultApp"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/{app}/disconnect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Disconnect team conferencing application */
        delete: operations["OrganizationsConferencingController_disconnectTeamApp"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/conferencing/{app}/oauth/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Save conferencing app OAuth credentials */
        get: operations["OrganizationsConferencingController_saveTeamOauthCredentials"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/event-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get team event types */
        get: operations["OrganizationsEventTypesController_getTeamEventTypes"];
        put?: never;
        /** Create an event type */
        post: operations["OrganizationsEventTypesController_createTeamEventType"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/event-types/{eventTypeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an event type */
        get: operations["OrganizationsEventTypesController_getTeamEventType"];
        put?: never;
        post?: never;
        /** Delete a team event type */
        delete: operations["OrganizationsEventTypesController_deleteTeamEventType"];
        options?: never;
        head?: never;
        /** Update a team event type */
        patch: operations["OrganizationsEventTypesController_updateTeamEventType"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/event-types/{eventTypeId}/create-phone-call": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a phone call */
        post: operations["OrganizationsEventTypesController_createPhoneCall"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/event-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all team event types */
        get: operations["OrganizationsEventTypesController_getTeamsEventTypes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all memberships */
        get: operations["OrganizationsTeamsMembershipsController_getAllOrgTeamMemberships"];
        put?: never;
        /** Create a membership */
        post: operations["OrganizationsTeamsMembershipsController_createOrgTeamMembership"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/memberships/{membershipId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a membership */
        get: operations["OrganizationsTeamsMembershipsController_getOrgTeamMembership"];
        put?: never;
        post?: never;
        /** Delete a membership */
        delete: operations["OrganizationsTeamsMembershipsController_deleteOrgTeamMembership"];
        options?: never;
        head?: never;
        /** Update a membership */
        patch: operations["OrganizationsTeamsMembershipsController_updateOrgTeamMembership"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/routing-forms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get team routing forms */
        get: operations["OrganizationsTeamsRoutingFormsController_getTeamRoutingForms"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/routing-forms/{routingFormId}/responses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization team routing form responses */
        get: operations["OrganizationsTeamsRoutingFormsResponsesController_getRoutingFormResponses"];
        put?: never;
        /** Create routing form response and get available slots */
        post: operations["OrganizationsTeamsRoutingFormsResponsesController_createRoutingFormResponse"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/routing-forms/{routingFormId}/responses/{responseId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update routing form response */
        patch: operations["OrganizationsTeamsRoutingFormsResponsesController_updateRoutingFormResponse"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/stripe/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Stripe connect URL for a team */
        get: operations["OrganizationsStripeController_getTeamStripeConnectUrl"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/stripe/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check team Stripe connection */
        get: operations["OrganizationsStripeController_checkTeamStripeConnection"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/stripe/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Save Stripe credentials */
        get: operations["OrganizationsStripeController_save"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/users/{userId}/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get schedules of a team member */
        get: operations["OrganizationsTeamsSchedulesController_getUserSchedules"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/workflows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization team workflows */
        get: operations["OrganizationTeamWorkflowsController_getWorkflows"];
        put?: never;
        /** Create organization team workflow */
        post: operations["OrganizationTeamWorkflowsController_createWorkflow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/workflows/{workflowId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get organization team workflow */
        get: operations["OrganizationTeamWorkflowsController_getWorkflowById"];
        put?: never;
        post?: never;
        /** Delete organization team workflow */
        delete: operations["OrganizationTeamWorkflowsController_deleteWorkflow"];
        options?: never;
        head?: never;
        /** Update organization team workflow */
        patch: operations["OrganizationTeamWorkflowsController_updateWorkflow"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all users */
        get: operations["OrganizationsUsersController_getOrganizationsUsers"];
        put?: never;
        /** Create a user */
        post: operations["OrganizationsUsersController_createOrganizationUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a user */
        delete: operations["OrganizationsUsersController_deleteOrganizationUser"];
        options?: never;
        head?: never;
        /** Update a user */
        patch: operations["OrganizationsUsersController_updateOrganizationUser"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all bookings for an organization user */
        get: operations["OrganizationsUsersBookingsController_getOrganizationUserBookings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}/ooo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all out-of-office entries for a user */
        get: operations["OrganizationsUsersOOOController_getOrganizationUserOOO"];
        put?: never;
        /** Create an out-of-office entry for a user */
        post: operations["OrganizationsUsersOOOController_createOrganizationUserOOO"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}/ooo/{oooId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete an out-of-office entry for a user */
        delete: operations["OrganizationsUsersOOOController_deleteOrganizationUserOOO"];
        options?: never;
        head?: never;
        /** Update an out-of-office entry for a user */
        patch: operations["OrganizationsUsersOOOController_updateOrganizationUserOOO"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/ooo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all out-of-office entries for organization users */
        get: operations["OrganizationsUsersOOOController_getOrganizationUsersOOO"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all schedules */
        get: operations["OrganizationsSchedulesController_getUserSchedules"];
        put?: never;
        /** Create a schedule */
        post: operations["OrganizationsSchedulesController_createUserSchedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/users/{userId}/schedules/{scheduleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a schedule */
        get: operations["OrganizationsSchedulesController_getUserSchedule"];
        put?: never;
        post?: never;
        /** Delete a schedule */
        delete: operations["OrganizationsSchedulesController_deleteUserSchedule"];
        options?: never;
        head?: never;
        /** Update a schedule */
        patch: operations["OrganizationsSchedulesController_updateUserSchedule"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all webhooks */
        get: operations["OrganizationsWebhooksController_getAllOrganizationWebhooks"];
        put?: never;
        /** Create a webhook */
        post: operations["OrganizationsWebhooksController_createOrganizationWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a webhook */
        get: operations["OrganizationsWebhooksController_getOrganizationWebhook"];
        put?: never;
        post?: never;
        /** Delete a webhook */
        delete: operations["OrganizationsWebhooksController_deleteWebhook"];
        options?: never;
        head?: never;
        /** Update a webhook */
        patch: operations["OrganizationsWebhooksController_updateOrgWebhook"];
        trace?: never;
    };
    "/v2/api-keys/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh API Key
         * @description Generate a new API key and delete the current one. Provide API key to refresh as a Bearer token in the Authorization header (e.g. "Authorization: Bearer <apiKey>").
         */
        post: operations["ApiKeysController_refresh"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all bookings */
        get: operations["BookingsController_2024_08_13_getBookings"];
        put?: never;
        /**
         * Create a booking
         * @description
         *           POST /v2/bookings is used to create regular bookings, recurring bookings and instant bookings. The request bodies for all 3 are almost the same except:
         *           If eventTypeId in the request body is id of a regular event, then regular booking is created.
         *
         *           If it is an id of a recurring event type, then recurring booking is created.
         *
         *           Meaning that the request bodies are equal but the outcome depends on what kind of event type it is with the goal of making it as seamless for developers as possible.
         *
         *           For team event types it is possible to create instant meeting. To do that just pass `"instant": true` to the request body.
         *
         *           The start needs to be in UTC aka if the timezone is GMT+2 in Rome and meeting should start at 11, then UTC time should have hours 09:00 aka without time zone.
         *
         *           Finally, there are 2 ways to book an event type belonging to an individual user:
         *           1. Provide `eventTypeId` in the request body.
         *           2. Provide `eventTypeSlug` and `username` and optionally `organizationSlug` if the user with the username is within an organization.
         *
         *           And 2 ways to book and event type belonging to a team:
         *           1. Provide `eventTypeId` in the request body.
         *           2. Provide `eventTypeSlug` and `teamSlug` and optionally `organizationSlug` if the team with the teamSlug is within an organization.
         *
         */
        post: operations["BookingsController_2024_08_13_createBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a booking
         * @description `:bookingUid` can be
         *
         *           1. uid of a normal booking
         *
         *           2. uid of one of the recurring booking recurrences
         *
         *           3. uid of recurring booking which will return an array of all recurring booking recurrences (stored as recurringBookingUid on one of the individual recurrences).
         */
        get: operations["BookingsController_2024_08_13_getBooking"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/recordings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all the recordings for the booking
         * @description Fetches all the recordings for the booking `:bookingUid`
         */
        get: operations["BookingsController_2024_08_13_getBookingRecordings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/transcripts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all the transcripts download links for the booking
         * @description Fetches all the transcripts download links for the booking `:bookingUid`
         */
        get: operations["BookingsController_2024_08_13_getBookingTranscripts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/reschedule": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reschedule a booking
         * @description Reschedule a booking or seated booking
         */
        post: operations["BookingsController_2024_08_13_rescheduleBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel a booking
         * @description :bookingUid can be :bookingUid of an usual booking, individual recurrence or recurring booking to cancel all recurrences.
         *
         *
         *     Cancelling seated bookings:
         *         It is possible to cancel specific seat within a booking as an attendee or all of the seats as the host.
         *
         *     1. As an attendee - provide :bookingUid in the request URL `/bookings/:bookingUid/cancel` and seatUid in the request body `{"seatUid": "123-123-123"}` . This will remove this particular attendance from the booking.
         *
         *     2. As the host - host can cancel booking for all attendees aka for every seat. Provide :bookingUid in the request URL `/bookings/:bookingUid/cancel` and cancellationReason in the request body `{"cancellationReason": "Will travel"}` and `Authorization: Bearer token` request header where token is event type owner (host) credential. This will cancel the booking for all attendees.
         *
         *
         *     Cancelling recurring seated bookings:
         *         For recurring seated bookings it is not possible to cancel all of them with 1 call
         *         like with non-seated recurring bookings by providing recurring bookind uid - you have to cancel each recurrence booking by its bookingUid + seatUid.
         */
        post: operations["BookingsController_2024_08_13_cancelBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/mark-absent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Mark a booking absence
         * @description The provided authorization header refers to the owner of the booking.
         */
        post: operations["BookingsController_2024_08_13_markNoShow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/reassign": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reassign a booking to auto-selected host
         * @description Currently only supports reassigning host for round robin bookings. The provided authorization header refers to the owner of the booking.
         */
        post: operations["BookingsController_2024_08_13_reassignBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/reassign/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reassign a booking to a specific host
         * @description Currently only supports reassigning host for round robin bookings. The provided authorization header refers to the owner of the booking.
         */
        post: operations["BookingsController_2024_08_13_reassignBookingToUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/confirm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm a booking
         * @description The provided authorization header refers to the owner of the booking.
         */
        post: operations["BookingsController_2024_08_13_confirmBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/decline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Decline a booking
         * @description The provided authorization header refers to the owner of the booking.
         */
        post: operations["BookingsController_2024_08_13_declineBooking"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/calendar-links": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get 'Add to Calendar' links for a booking
         * @description Retrieve calendar links for a booking that can be used to add the event to various calendar services. Returns links for Google Calendar, Microsoft Office, Microsoft Outlook, and a downloadable ICS file.
         */
        get: operations["BookingsController_2024_08_13_getCalendarLinks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/bookings/{bookingUid}/references": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get booking references */
        get: operations["BookingsController_2024_08_13_getBookingReferences"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/event/{eventUid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get meeting details from calendar
         * @description Returns detailed information about a meeting including attendance metrics
         */
        get: operations["CalUnifiedCalendarsController_getCalendarEventDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/ics-feed/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Save an ICS feed */
        post: operations["CalendarsController_createIcsFeed"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/ics-feed/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check an ICS feed */
        get: operations["CalendarsController_checkIcsFeed"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/busy-times": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get busy times
         * @description Get busy times from a calendar. Example request URL is `https://api.cal.com/v2/calendars/busy-times?loggedInUsersTz=Europe%2FMadrid&dateFrom=2024-12-18&dateTo=2024-12-18&calendarsToLoad[0][credentialId]=135&calendarsToLoad[0][externalId]=skrauciz%40gmail.com`
         */
        get: operations["CalendarsController_getBusyTimes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all calendars */
        get: operations["CalendarsController_getCalendars"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get OAuth connect URL */
        get: operations["CalendarsController_redirect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Save Google or Outlook calendar credentials */
        get: operations["CalendarsController_save"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/credentials": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Save Apple calendar credentials */
        post: operations["CalendarsController_syncCredentials"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check a calendar connection */
        get: operations["CalendarsController_check"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/calendars/{calendar}/disconnect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Disconnect a calendar */
        post: operations["CalendarsController_deleteCalendarCredentials"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/{app}/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Connect your conferencing application */
        post: operations["ConferencingController_connect"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/{app}/oauth/auth-url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get OAuth conferencing app auth URL */
        get: operations["ConferencingController_redirect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/{app}/oauth/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Conferencing app OAuth callback */
        get: operations["ConferencingController_save"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List your conferencing applications */
        get: operations["ConferencingController_listInstalledConferencingApps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/{app}/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set your default conferencing application */
        post: operations["ConferencingController_default"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get your default conferencing application */
        get: operations["ConferencingController_getDefault"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/conferencing/{app}/disconnect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Disconnect your conferencing application */
        delete: operations["ConferencingController_disconnect"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/destination-calendars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update destination calendars */
        put: operations["DestinationCalendarsController_updateDestinationCalendars"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/event-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all event types */
        get: operations["EventTypesController_2024_06_14_getEventTypes"];
        put?: never;
        /** Create an event type */
        post: operations["EventTypesController_2024_06_14_createEventType"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/event-types/{eventTypeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an event type */
        get: operations["EventTypesController_2024_06_14_getEventTypeById"];
        put?: never;
        post?: never;
        /** Delete an event type */
        delete: operations["EventTypesController_2024_06_14_deleteEventType"];
        options?: never;
        head?: never;
        /** Update an event type */
        patch: operations["EventTypesController_2024_06_14_updateEventType"];
        trace?: never;
    };
    "/v2/event-types/{eventTypeId}/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all webhooks */
        get: operations["EventTypeWebhooksController_getEventTypeWebhooks"];
        put?: never;
        /** Create a webhook */
        post: operations["EventTypeWebhooksController_createEventTypeWebhook"];
        /** Delete all webhooks */
        delete: operations["EventTypeWebhooksController_deleteAllEventTypeWebhooks"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/event-types/{eventTypeId}/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a webhook */
        get: operations["EventTypeWebhooksController_getEventTypeWebhook"];
        put?: never;
        post?: never;
        /** Delete a webhook */
        delete: operations["EventTypeWebhooksController_deleteEventTypeWebhook"];
        options?: never;
        head?: never;
        /** Update a webhook */
        patch: operations["EventTypeWebhooksController_updateEventTypeWebhook"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/organizations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all organizations within an organization
         * @description Requires the user to have at least the 'ORG_ADMIN' role within the organization. Additionally, for platform, the plan must be 'SCALE' or higher to access this endpoint.
         */
        get: operations["OrganizationsOrganizationsController_getOrganizations"];
        put?: never;
        /**
         * Create an organization within an organization
         * @description Requires the user to have at least the 'ORG_ADMIN' role within the organization. Additionally, for platform, the plan must be 'SCALE' or higher to access this endpoint.
         */
        post: operations["OrganizationsOrganizationsController_createOrganization"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/organizations/{managedOrganizationId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an organization within an organization
         * @description Requires the user to have at least the 'ORG_ADMIN' role within the organization. Additionally, for platform, the plan must be 'SCALE' or higher to access this endpoint.
         */
        get: operations["OrganizationsOrganizationsController_getOrganization"];
        put?: never;
        post?: never;
        /**
         * Delete an organization within an organization
         * @description Requires the user to have at least the 'ORG_ADMIN' role within the organization. Additionally, for platform, the plan must be 'SCALE' or higher to access this endpoint.
         */
        delete: operations["OrganizationsOrganizationsController_deleteOrganization"];
        options?: never;
        head?: never;
        /**
         * Update an organization within an organization
         * @description Requires the user to have at least the 'ORG_ADMIN' role within the organization. Additionally, for platform, the plan must be 'SCALE' or higher to access this endpoint.
         */
        patch: operations["OrganizationsOrganizationsController_updateOrganization"];
        trace?: never;
    };
    "/v2/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get my profile */
        get: operations["MeController_getMe"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update my profile */
        patch: operations["MeController_updateMe"];
        trace?: never;
    };
    "/v2/oauth-clients": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all OAuth clients */
        get: operations["OAuthClientsController_getOAuthClients"];
        put?: never;
        /** Create an OAuth client */
        post: operations["OAuthClientsController_createOAuthClient"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/oauth-clients/{clientId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an OAuth client */
        get: operations["OAuthClientsController_getOAuthClientById"];
        put?: never;
        post?: never;
        /** Delete an OAuth client */
        delete: operations["OAuthClientsController_deleteOAuthClient"];
        options?: never;
        head?: never;
        /** Update an OAuth client */
        patch: operations["OAuthClientsController_updateOAuthClient"];
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/emails/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request email verification code
         * @description Sends a verification code to the email
         */
        post: operations["OrgTeamsVerifiedResourcesController_requestEmailVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/phones/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request phone number verification code
         * @description Sends a verification code to the phone number
         */
        post: operations["OrgTeamsVerifiedResourcesController_requestPhoneVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/emails/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify an email for an org team
         * @description Use code to verify an email
         */
        post: operations["OrgTeamsVerifiedResourcesController_verifyEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/phones/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a phone number for an org team
         * @description Use code to verify a phone number
         */
        post: operations["OrgTeamsVerifiedResourcesController_verifyPhoneNumber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/emails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified emails of an org team */
        get: operations["OrgTeamsVerifiedResourcesController_getVerifiedEmails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/phones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified phone numbers of an org team */
        get: operations["OrgTeamsVerifiedResourcesController_getVerifiedPhoneNumbers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/emails/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified email of an org team by id */
        get: operations["OrgTeamsVerifiedResourcesController_getVerifiedEmailById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/organizations/{orgId}/teams/{teamId}/verified-resources/phones/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified phone number of an org team by id */
        get: operations["OrgTeamsVerifiedResourcesController_getVerifiedPhoneById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/routing-forms/{routingFormId}/calculate-slots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calculate slots based on routing form response
         * @description It will not actually save the response just return the routed event type and slots when it can be booked.
         */
        post: operations["RoutingFormsController_calculateSlotsBasedOnRoutingFormResponse"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all schedules
         * @description Get all schedules of the authenticated user.
         */
        get: operations["SchedulesController_2024_06_11_getSchedules"];
        put?: never;
        /**
         * Create a schedule
         * @description
         *           Create a schedule for the authenticated user.
         *
         *           The point of creating schedules is for event types to be available at specific times.
         *
         *           The first goal of schedules is to have a default schedule. If you are platform customer and created managed users, then it is important to note that each managed user should have a default schedule.
         *           1. If you passed `timeZone` when creating managed user, then the default schedule from Monday to Friday from 9AM to 5PM will be created with that timezone. The managed user can then change the default schedule via the `AvailabilitySettings` atom.
         *           2. If you did not, then we assume you want the user to have this specific schedule right away. You should create a default schedule by specifying
         *           `"isDefault": true` in the request body. Until the user has a default schedule the user can't be booked nor manage their schedule via the AvailabilitySettings atom.
         *
         *           The second goal of schedules is to create another schedule that event types can point to. This is useful for when an event is booked because availability is not checked against the default schedule but instead against that specific schedule.
         *           After creating a non-default schedule, you can update an event type to point to that schedule via the PATCH `event-types/{eventTypeId}` endpoint.
         *
         *           When specifying start time and end time for each day use the 24 hour format e.g. 08:00, 15:00 etc.
         *
         */
        post: operations["SchedulesController_2024_06_11_createSchedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/schedules/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get default schedule
         * @description Get the default schedule of the authenticated user.
         */
        get: operations["SchedulesController_2024_06_11_getDefaultSchedule"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/schedules/{scheduleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a schedule */
        get: operations["SchedulesController_2024_06_11_getSchedule"];
        put?: never;
        post?: never;
        /** Delete a schedule */
        delete: operations["SchedulesController_2024_06_11_deleteSchedule"];
        options?: never;
        head?: never;
        /** Update a schedule */
        patch: operations["SchedulesController_2024_06_11_updateSchedule"];
        trace?: never;
    };
    "/v2/selected-calendars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Add a selected calendar */
        post: operations["SelectedCalendarsController_addSelectedCalendar"];
        /** Delete a selected calendar */
        delete: operations["SelectedCalendarsController_deleteSelectedCalendar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/slots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get available time slots for an event type
         * @description
         *           There are 4 ways to get available slots for event type of an individual user:
         *
         *           1. By event type id. Event type id can be of user and team event types. Example '/v2/slots?eventTypeId=10&start=2050-09-05&end=2050-09-06&timeZone=Europe/Rome'
         *
         *           2. By event type slug + username. Example '/v2/slots?eventTypeSlug=intro&username=bob&start=2050-09-05&end=2050-09-06'
         *
         *           3. By event type slug + username + organization slug when searching within an organization. Example '/v2/slots?organizationSlug=org-slug&eventTypeSlug=intro&username=bob&start=2050-09-05&end=2050-09-06'
         *
         *           4. By usernames only (used for dynamic event type - there is no specific event but you want to know when 2 or more people are available). Example '/v2/slots?usernames=alice,bob&username=bob&organizationSlug=org-slug&start=2050-09-05&end=2050-09-06'. As you see you also need to provide the slug of the organization to which each user in the 'usernames' array belongs.
         *
         *           And 3 ways to get available slots for team event type:
         *
         *           1. By team event type id. Example '/v2/slots?eventTypeId=10&start=2050-09-05&end=2050-09-06&timeZone=Europe/Rome'
         *
         *           2. By team event type slug + team slug. Example '/v2/slots?eventTypeSlug=intro&teamSlug=team-slug&start=2050-09-05&end=2050-09-06'
         *
         *           3. By team event type slug + team slug + organization slug when searching within an organization. Example '/v2/slots?organizationSlug=org-slug&eventTypeSlug=intro&teamSlug=team-slug&start=2050-09-05&end=2050-09-06'
         *
         *           All of them require "start" and "end" query parameters which define the time range for which available slots should be checked.
         *           Optional parameters are:
         *           - timeZone: Time zone in which the available slots should be returned. Defaults to UTC.
         *           - duration: Only use for event types that allow multiple durations or for dynamic event types. If not passed for multiple duration event types defaults to default duration. For dynamic event types defaults to 30 aka each returned slot is 30 minutes long. So duration=60 means that returned slots will be each 60 minutes long.
         *           - format: Format of the slots. By default return is an object where each key is date and value is array of slots as string. If you want to get start and end of each slot use "range" as value.
         *           - bookingUidToReschedule: When rescheduling an existing booking, provide the booking's unique identifier to exclude its time slot from busy time calculations. This ensures the original booking time appears as available for rescheduling.
         *
         */
        get: operations["SlotsController_2024_09_04_getAvailableSlots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/slots/reservations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reserve a slot
         * @description Make a slot not available for others to book for a certain period of time. If you authenticate using oAuth credentials, api key or access token
         *         then you can also specify custom duration for how long the slot should be reserved for (defaults to 5 minutes).
         */
        post: operations["SlotsController_2024_09_04_reserveSlot"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/slots/reservations/{uid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get reserved slot */
        get: operations["SlotsController_2024_09_04_getReservedSlot"];
        put?: never;
        post?: never;
        /** Delete a reserved slot */
        delete: operations["SlotsController_2024_09_04_deleteReservedSlot"];
        options?: never;
        head?: never;
        /** Update a reserved slot */
        patch: operations["SlotsController_2024_09_04_updateReservedSlot"];
        trace?: never;
    };
    "/v2/stripe/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Stripe connect URL */
        get: operations["StripeController_redirect"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/stripe/save": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Save Stripe credentials */
        get: operations["StripeController_save"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/stripe/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check Stripe connection */
        get: operations["StripeController_check"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get teams */
        get: operations["TeamsController_getTeams"];
        put?: never;
        /** Create a team */
        post: operations["TeamsController_createTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a team */
        get: operations["TeamsController_getTeam"];
        put?: never;
        post?: never;
        /** Delete a team */
        delete: operations["TeamsController_deleteTeam"];
        options?: never;
        head?: never;
        /** Update a team */
        patch: operations["TeamsController_updateTeam"];
        trace?: never;
    };
    "/v2/teams/{teamId}/event-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a team event type */
        get: operations["TeamsEventTypesController_getTeamEventTypes"];
        put?: never;
        /** Create an event type */
        post: operations["TeamsEventTypesController_createTeamEventType"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/event-types/{eventTypeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an event type */
        get: operations["TeamsEventTypesController_getTeamEventType"];
        put?: never;
        post?: never;
        /** Delete a team event type */
        delete: operations["TeamsEventTypesController_deleteTeamEventType"];
        options?: never;
        head?: never;
        /** Update a team event type */
        patch: operations["TeamsEventTypesController_updateTeamEventType"];
        trace?: never;
    };
    "/v2/teams/{teamId}/event-types/{eventTypeId}/create-phone-call": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a phone call */
        post: operations["TeamsEventTypesController_createPhoneCall"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/memberships": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all memberships */
        get: operations["TeamsMembershipsController_getTeamMemberships"];
        put?: never;
        /** Create a membership */
        post: operations["TeamsMembershipsController_createTeamMembership"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/memberships/{membershipId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a membership */
        get: operations["TeamsMembershipsController_getTeamMembership"];
        put?: never;
        post?: never;
        /** Delete a membership */
        delete: operations["TeamsMembershipsController_deleteTeamMembership"];
        options?: never;
        head?: never;
        /** Update membership */
        patch: operations["TeamsMembershipsController_updateTeamMembership"];
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/emails/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request email verification code
         * @description Sends a verification code to the Email
         */
        post: operations["TeamsVerifiedResourcesController_requestEmailVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/phones/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request phone number verification code
         * @description Sends a verification code to the phone number
         */
        post: operations["TeamsVerifiedResourcesController_requestPhoneVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/emails/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify an email for a team
         * @description Use code to verify an email
         */
        post: operations["TeamsVerifiedResourcesController_verifyEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/phones/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a phone number for an org team
         * @description Use code to verify a phone number
         */
        post: operations["TeamsVerifiedResourcesController_verifyPhoneNumber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/emails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified emails of a team */
        get: operations["TeamsVerifiedResourcesController_getVerifiedEmails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/phones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified phone numbers of a team */
        get: operations["TeamsVerifiedResourcesController_getVerifiedPhoneNumbers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/emails/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified email of a team by id */
        get: operations["TeamsVerifiedResourcesController_getVerifiedEmailById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/teams/{teamId}/verified-resources/phones/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified phone number of a team by id */
        get: operations["TeamsVerifiedResourcesController_getVerifiedPhoneById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/emails/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request email verification code
         * @description Sends a verification code to the email
         */
        post: operations["UserVerifiedResourcesController_requestEmailVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/phones/verification-code/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request phone number verification code
         * @description Sends a verification code to the phone number
         */
        post: operations["UserVerifiedResourcesController_requestPhoneVerificationCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/emails/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify an email
         * @description Use code to verify an email
         */
        post: operations["UserVerifiedResourcesController_verifyEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/phones/verification-code/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a phone number
         * @description Use code to verify a phone number
         */
        post: operations["UserVerifiedResourcesController_verifyPhoneNumber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/emails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified emails */
        get: operations["UserVerifiedResourcesController_getVerifiedEmails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/phones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of verified phone numbers */
        get: operations["UserVerifiedResourcesController_getVerifiedPhoneNumbers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/emails/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified email by id */
        get: operations["UserVerifiedResourcesController_getVerifiedEmailById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/verified-resources/phones/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get verified phone number by id */
        get: operations["UserVerifiedResourcesController_getVerifiedPhoneById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all webhooks
         * @description Gets a paginated list of webhooks for the authenticated user.
         */
        get: operations["WebhooksController_getWebhooks"];
        put?: never;
        /** Create a webhook */
        post: operations["WebhooksController_createWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/webhooks/{webhookId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a webhook */
        get: operations["WebhooksController_getWebhook"];
        put?: never;
        post?: never;
        /** Delete a webhook */
        delete: operations["WebhooksController_deleteWebhook"];
        options?: never;
        head?: never;
        /** Update a webhook */
        patch: operations["WebhooksController_updateWebhook"];
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ManagedUserOutput: {
            /** @example 1 */
            id: number;
            /** @example alice+cluo37fwd0001khkzqqynkpj3@example.com */
            email: string;
            /** @example alice */
            username: string | null;
            /** @example alice */
            name: string | null;
            /** @example bio */
            bio: string | null;
            /** @example America/New_York */
            timeZone: string;
            /** @example Sunday */
            weekStart: string;
            /** @example 2024-04-01T00:00:00.000Z */
            createdDate: string;
            /** @example 12 */
            timeFormat: number | null;
            /** @example null */
            defaultScheduleId: number | null;
            /**
             * @example en
             * @enum {string}
             */
            locale?: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
            /**
             * @description URL of the user's avatar image
             * @example https://cal.com/api/avatar/2b735186-b01b-46d3-87da-019b8f61776b.png
             */
            avatarUrl?: string | null;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
        };
        GetManagedUsersOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ManagedUserOutput"][];
        };
        CreateManagedUserInput: {
            /** @example alice@example.com */
            email: string;
            /**
             * @description Managed user's name is used in emails
             * @example Alice Smith
             */
            name: string;
            /**
             * @description Must be a number 12 or 24
             * @example 12
             * @enum {number}
             */
            timeFormat?: 12 | 24;
            /**
             * @example Monday
             * @enum {string}
             */
            weekStart?: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";
            /**
             * @description Timezone is used to create user's default schedule from Monday to Friday from 9AM to 5PM. If it is not passed then user does not have
             *           a default schedule and it must be created manually via the /schedules endpoint. Until the schedule is created, the user can't access availability atom to set his / her availability nor booked.
             *           It will default to Europe/London if not passed.
             * @example America/New_York
             */
            timeZone?: string;
            /**
             * @example en
             * @enum {string}
             */
            locale?: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
            /**
             * @description URL of the user's avatar image
             * @example https://cal.com/api/avatar/2b735186-b01b-46d3-87da-019b8f61776b.png
             */
            avatarUrl?: string;
            /**
             * @description Bio
             * @example I am a bio
             */
            bio?: string;
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
        };
        CreateManagedUserData: {
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 */
            accessToken: string;
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 */
            refreshToken: string;
            user: components["schemas"]["ManagedUserOutput"];
            accessTokenExpiresAt: number;
            refreshTokenExpiresAt: number;
        };
        CreateManagedUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["CreateManagedUserData"];
            error?: Record<string, never>;
        };
        GetManagedUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ManagedUserOutput"];
        };
        UpdateManagedUserInput: {
            email?: string;
            name?: string;
            /**
             * @description Must be 12 or 24
             * @example 12
             * @enum {number}
             */
            timeFormat?: 12 | 24;
            defaultScheduleId?: number;
            /**
             * @example Monday
             * @enum {string}
             */
            weekStart?: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";
            timeZone?: string;
            /**
             * @example en
             * @enum {string}
             */
            locale?: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
            /**
             * @description URL of the user's avatar image
             * @example https://cal.com/api/avatar/2b735186-b01b-46d3-87da-019b8f61776b.png
             */
            avatarUrl?: string;
            /**
             * @description Bio
             * @example I am a bio
             */
            bio?: string;
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
        };
        KeysDto: {
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 */
            accessToken: string;
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 */
            refreshToken: string;
            accessTokenExpiresAt: number;
            refreshTokenExpiresAt: number;
        };
        KeysResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["KeysDto"];
        };
        CreateOAuthClientInput: {
            logo?: string;
            name: string;
            redirectUris: string[];
            /** @description Array of permission keys like ["BOOKING_READ", "BOOKING_WRITE"]. Use ["*"] to grant all permissions. */
            permissions: ("EVENT_TYPE_READ" | "EVENT_TYPE_WRITE" | "BOOKING_READ" | "BOOKING_WRITE" | "SCHEDULE_READ" | "SCHEDULE_WRITE" | "APPS_READ" | "APPS_WRITE" | "PROFILE_READ" | "PROFILE_WRITE" | "*")[];
            bookingRedirectUri?: string;
            bookingCancelRedirectUri?: string;
            bookingRescheduleRedirectUri?: string;
            areEmailsEnabled?: boolean;
            /**
             * @description If true, when creating a managed user the managed user will have 4 default event types: 30 and 60 minutes without Cal video, 30 and 60 minutes with Cal video. Set this as false if you want to create a managed user and then manually create event types for the user.
             * @default false
             */
            areDefaultEventTypesEnabled: boolean;
            /**
             * @description If true and if managed user has calendar connected, calendar events will be created. Disable it if you manually create calendar events. Default to true.
             * @default true
             */
            areCalendarEventsEnabled: boolean;
        };
        CreateOAuthClientOutput: {
            /** @example clsx38nbl0001vkhlwin9fmt0 */
            clientId: string;
            /** @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoib2F1dGgtY2xpZW50Iiwi */
            clientSecret: string;
        };
        CreateOAuthClientResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @example {
             *       "clientId": "clsx38nbl0001vkhlwin9fmt0",
             *       "clientSecret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoib2F1dGgtY2xpZW50Iiwi"
             *     } */
            data: components["schemas"]["CreateOAuthClientOutput"];
        };
        PlatformOAuthClientDto: {
            /** @example clsx38nbl0001vkhlwin9fmt0 */
            id: string;
            /** @example MyClient */
            name: string;
            /** @example secretValue */
            secret: string;
            /**
             * @description Array of permission keys like ["BOOKING_READ", "BOOKING_WRITE"]
             * @example [
             *       "BOOKING_READ",
             *       "BOOKING_WRITE"
             *     ]
             */
            permissions: ("EVENT_TYPE_READ" | "EVENT_TYPE_WRITE" | "BOOKING_READ" | "BOOKING_WRITE" | "SCHEDULE_READ" | "SCHEDULE_WRITE" | "APPS_READ" | "APPS_WRITE" | "PROFILE_READ" | "PROFILE_WRITE")[];
            /** @example https://example.com/logo.png */
            logo?: Record<string, never>;
            /** @example [
             *       "https://example.com/callback"
             *     ] */
            redirectUris: string[];
            /** @example 1 */
            organizationId: number;
            /**
             * Format: date-time
             * @example 2024-03-23T08:33:21.851Z
             */
            createdAt: string;
            /** @example true */
            areEmailsEnabled: boolean;
            /**
             * @description If enabled, when creating a managed user the managed user will have 4 default event types: 30 and 60 minutes without Cal video, 30 and 60 minutes with Cal video. Leave this disabled if you want to create a managed user and then manually create event types for the user.
             * @example true
             */
            areDefaultEventTypesEnabled: boolean;
            /**
             * @description If true and if managed user has calendar connected, calendar events will be created. Disable it if you manually create calendar events. Default to true.
             * @example true
             */
            areCalendarEventsEnabled: boolean;
            /** @example https://example.com/booking-redirect */
            bookingRedirectUri?: string;
            /** @example https://example.com/booking-cancel */
            bookingCancelRedirectUri?: string;
            /** @example https://example.com/booking-reschedule */
            bookingRescheduleRedirectUri?: string;
        };
        GetOAuthClientsResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["PlatformOAuthClientDto"][];
        };
        GetOAuthClientResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["PlatformOAuthClientDto"];
        };
        UpdateOAuthClientInput: {
            logo?: string;
            name?: string;
            redirectUris?: string[];
            bookingRedirectUri?: string;
            bookingCancelRedirectUri?: string;
            bookingRescheduleRedirectUri?: string;
            areEmailsEnabled?: boolean;
            /** @description If true, when creating a managed user the managed user will have 4 default event types: 30 and 60 minutes without Cal video, 30 and 60 minutes with Cal video. Set this as false if you want to create a managed user and then manually create event types for the user. */
            areDefaultEventTypesEnabled?: boolean;
            /** @description If true and if managed user has calendar connected, calendar events will be created. Disable it if you manually create calendar events. Default to true. */
            areCalendarEventsEnabled?: boolean;
        };
        RefreshTokenInput: {
            /** @description Managed user's refresh token. */
            refreshToken: string;
        };
        RefreshApiKeyInput: {
            /**
             * @description For how many days is managed organization api key valid. Defaults to 30 days.
             * @default 30
             * @example 60
             */
            apiKeyDaysValid: number;
            /**
             * @description If true, organization api key never expires.
             * @example true
             */
            apiKeyNeverExpires?: boolean;
        };
        ApiKeyOutput: {
            apiKey: string;
        };
        RefreshApiKeyOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ApiKeyOutput"];
        };
        BookerLayouts_2024_06_14: {
            /** @enum {string} */
            defaultLayout: "month" | "week" | "column";
            /** @description Array of valid layouts - month, week or column */
            enabledLayouts: ("month" | "week" | "column")[];
        };
        EventTypeColor_2024_06_14: {
            /**
             * @description Color used for event types in light theme
             * @example #292929
             */
            lightThemeHex: string;
            /**
             * @description Color used for event types in dark theme
             * @example #fafafa
             */
            darkThemeHex: string;
        };
        DestinationCalendar_2024_06_14: {
            /** @description The integration type of the destination calendar. Refer to the /api/v2/calendars endpoint to retrieve the integration type of your connected calendars. */
            integration: string;
            /** @description The external ID of the destination calendar. Refer to the /api/v2/calendars endpoint to retrieve the external IDs of your connected calendars. */
            externalId: string;
        };
        InputAddressLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `address`
             * @example address
             */
            type: string;
            /** @example 123 Example St, City, Country */
            address: string;
            public: boolean;
        };
        InputLinkLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `link`
             * @example link
             */
            type: string;
            /** @example https://customvideo.com/join/123456 */
            link: string;
            public: boolean;
        };
        InputIntegrationLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `integration`
             * @example integration
             */
            type: string;
            /**
             * @example cal-video
             * @enum {string}
             */
            integration: "cal-video" | "google-meet" | "office365-video" | "zoom";
        };
        InputPhoneLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `phone`
             * @example phone
             */
            type: string;
            /** @example +37120993151 */
            phone: string;
            public: boolean;
        };
        PhoneFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `phone`
             * @example phone
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking. Special slug is `attendeePhoneNumber` - if you create
             *           a phone input field with this slug for organization team event type you can create an organization team event type that can be booked using phone without requiring an email by setting {"type": "email", "required": false, "hidden": true} to the email booking field input in the request body.
             * @example some-slug
             */
            slug: string;
            label: string;
            required: boolean;
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `phone` and the URL contains query parameter `&phone=1234567890`,      the phone field will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{phone: '+37122222222'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        AddressFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `address`
             * @example address
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your address */
            label: string;
            required: boolean;
            /** @example e.g., 1234 Main St */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `address` and the URL contains query parameter `&address=1234 Main St, London`,      the address field will be prefilled with this value and disabled.  In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{address: 'mainstreat 10, new york'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        TextFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `text`
             * @example text
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your text */
            label: string;
            required: boolean;
            /** @example e.g., Enter text here */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `friend` and the URL contains query parameter `&friend=bob`,      the text field will be prefilled with this value and disabled.  In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{friend: 'bob'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        NumberFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `number`
             * @example number
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter a number */
            label: string;
            required: boolean;
            /** @example e.g., 100 */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `calories` and the URL contains query parameter `&calories=3000`,      the number field will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{calories: 3000}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        TextAreaFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `textarea`
             * @example textarea
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter detailed information */
            label: string;
            required: boolean;
            /** @example e.g., Detailed description here... */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `reflection` and the URL contains query parameter `&reflection=Today I shipped a feature`,      the text area will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{reflection: 'Today i shipped a feature'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        SelectFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `select`
             * @example select
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please select an option */
            label: string;
            required: boolean;
            /** @example Select... */
            placeholder: string;
            /** @example [
             *       "Option 1",
             *       "Option 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and options of this select field are ['english', 'italian'] and the URL contains query parameter `&language=italian`,      the 'italian' will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: 'italian'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        MultiSelectFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `multiselect`
             * @example multiselect
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please select multiple options */
            label: string;
            required: boolean;
            /** @example [
             *       "Option 1",
             *       "Option 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and the URL contains query parameter `&language=en&language=it`,      the 'en' and 'it' will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: ['en', 'it']}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        MultiEmailFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `multiemail`
             * @example multiemail
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter multiple emails */
            label: string;
            required: boolean;
            /** @example e.g., example@example.com */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `consultants` and the URL contains query parameter `&consultants=alice@gmail.com&consultants=bob@gmail.com`,      the these emails will be added and none more can be added. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{consultants: ['alice@gmail.com', 'bob@gmail.com']}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        CheckboxGroupFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `checkbox`
             * @example checkbox
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Select all that apply */
            label: string;
            required: boolean;
            /** @example [
             *       "Checkbox 1",
             *       "Checkbox 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `notify` and the URL contains query parameter `&notify=true`,      the checkbox will be selected and the checkbox field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{notify: true}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        RadioGroupFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `radio`
             * @example radio
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Select one option */
            label: string;
            required: boolean;
            /** @example [
             *       "Radio 1",
             *       "Radio 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and options of this select field are ['english', 'italian'] and the URL contains query parameter `&language=italian`,      the 'italian' radio button will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: 'italian'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        BooleanFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `boolean`
             * @example boolean
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Agree to terms? */
            label: string;
            required: boolean;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `notify` and the URL contains query parameter `&notify=true`,      the checkbox will be selected and the checkbox field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{notify: true}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        UrlFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `url`
             * @example url
             */
            type: string;
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your text */
            label: string;
            required: boolean;
            /** @example e.g., Enter url here */
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `videourl` and the URL contains query parameter `&videourl=https://youtube.com/abc`the url field will be prefilled with this value and disabled.       In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{videourl: 'https://caltube.com/123'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
        };
        BusinessDaysWindow_2024_06_14: {
            /**
             * @description Whether the window should be business days, calendar days or a range of dates
             * @enum {string}
             */
            type: "businessDays" | "calendarDays" | "range";
            /**
             * @description How many business day into the future can this event be booked
             * @example 5
             */
            value: number;
            /**
             * @description
             *           Determines the behavior of the booking window:
             *           - If **true**, the window is rolling. This means the number of available days will always be equal the specified 'value'
             *             and adjust dynamically as bookings are made. For example, if 'value' is 3 and availability is only on Mondays,
             *             a booker attempting to schedule on November 10 will see slots on November 11, 18, and 25. As one of these days
             *             becomes fully booked, a new day (e.g., December 2) will open up to ensure 3 available days are always visible.
             *           - If **false**, the window is fixed. This means the booking window only considers the next 'value' days from the
             *             moment someone is trying to book. For example, if 'value' is 3, availability is only on Mondays, and the current
             *             date is November 10, the booker will only see slots on November 11 because the window is restricted to the next
             *             3 calendar days (November 1012).
             *
             * @example true
             */
            rolling?: boolean;
        };
        CalendarDaysWindow_2024_06_14: {
            /**
             * @description Whether the window should be business days, calendar days or a range of dates
             * @enum {string}
             */
            type: "businessDays" | "calendarDays" | "range";
            /**
             * @description How many calendar days into the future can this event be booked
             * @example 5
             */
            value: number;
            /**
             * @description
             *           Determines the behavior of the booking window:
             *           - If **true**, the window is rolling. This means the number of available days will always be equal the specified 'value'
             *             and adjust dynamically as bookings are made. For example, if 'value' is 3 and availability is only on Mondays,
             *             a booker attempting to schedule on November 10 will see slots on November 11, 18, and 25. As one of these days
             *             becomes fully booked, a new day (e.g., December 2) will open up to ensure 3 available days are always visible.
             *           - If **false**, the window is fixed. This means the booking window only considers the next 'value' days from the
             *             moment someone is trying to book. For example, if 'value' is 3, availability is only on Mondays, and the current
             *             date is November 10, the booker will only see slots on November 11 because the window is restricted to the next
             *             3 calendar days (November 1012).
             *
             * @example true
             */
            rolling?: boolean;
        };
        RangeWindow_2024_06_14: {
            /**
             * @description Whether the window should be business days, calendar days or a range of dates
             * @enum {string}
             */
            type: "businessDays" | "calendarDays" | "range";
            /**
             * @description Date range for when this event can be booked.
             * @example [
             *       "2030-09-05",
             *       "2030-09-09"
             *     ]
             */
            value: string[];
        };
        BaseBookingLimitsCount_2024_06_14: {
            /**
             * @description The number of bookings per day
             * @example 1
             */
            day?: number;
            /**
             * @description The number of bookings per week
             * @example 2
             */
            week?: number;
            /**
             * @description The number of bookings per month
             * @example 3
             */
            month?: number;
            /**
             * @description The number of bookings per year
             * @example 4
             */
            year?: number;
            /** @default false */
            disabled: boolean;
        };
        Disabled_2024_06_14: {
            /**
             * @description Indicates if the option is disabled
             * @default false
             * @example true
             */
            disabled: boolean;
        };
        BaseBookingLimitsDuration_2024_06_14: {
            /**
             * @description The duration of bookings per day (must be a multiple of 15)
             * @example 60
             */
            day?: number;
            /**
             * @description The duration of bookings per week (must be a multiple of 15)
             * @example 120
             */
            week?: number;
            /**
             * @description The duration of bookings per month (must be a multiple of 15)
             * @example 180
             */
            month?: number;
            /**
             * @description The duration of bookings per year (must be a multiple of 15)
             * @example 240
             */
            year?: number;
        };
        Recurrence_2024_06_14: {
            /**
             * @description Repeats every {count} week | month | year
             * @example 10
             */
            interval: number;
            /**
             * @description Repeats for a maximum of {count} events
             * @example 10
             */
            occurrences: number;
            /** @enum {string} */
            frequency: "yearly" | "monthly" | "weekly";
        };
        NoticeThreshold_2024_06_14: {
            /**
             * @description The unit of time for the notice threshold (e.g., minutes, hours)
             * @example minutes
             */
            unit: string;
            /**
             * @description The time value for the notice threshold
             * @example 30
             */
            count: number;
        };
        BaseConfirmationPolicy_2024_06_14: {
            /**
             * @description The policy that determines when confirmation is required
             * @example always
             * @enum {string}
             */
            type: "always" | "time";
            /** @description The notice threshold required before confirmation is needed. Required when type is 'time'. */
            noticeThreshold?: components["schemas"]["NoticeThreshold_2024_06_14"];
            /** @description Unconfirmed bookings still block calendar slots. */
            blockUnconfirmedBookingsInBooker: boolean;
        };
        Seats_2024_06_14: {
            /**
             * @description Number of seats available per time slot
             * @example 4
             */
            seatsPerTimeSlot: number;
            /**
             * @description Show attendee information to other guests
             * @example true
             */
            showAttendeeInfo: boolean;
            /**
             * @description Display the count of available seats
             * @example true
             */
            showAvailabilityCount: boolean;
        };
        InputAttendeeAddressLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `attendeeAddress`
             * @example attendeeAddress
             */
            type: string;
        };
        InputAttendeePhoneLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `attendeePhone`
             * @example attendeePhone
             */
            type: string;
        };
        InputAttendeeDefinedLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `attendeeDefined`
             * @example attendeeDefined
             */
            type: string;
        };
        NameDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `name`. Used for having 1 booking field for both first name and last name.
             * @example name
             */
            type: string;
            label: string;
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&name=bob`,      the name field will be prefilled with this value and disabled. In case of Booker atom need to pass 'name' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{name: 'bob'}}`. See guide https://cal.com/docs/platform/guides/booking-fields */
            disableOnPrefill?: boolean;
        };
        EmailDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `email`
             * @example email
             */
            type: string;
            label: string;
            /** @description Can be set to false only for organization team event types and if you also pass booking field {type: "phone", slug: "attendeePhoneNumber", required: true, hidden: false, label: "whatever label"} of booking field type PhoneFieldInput_2024_06_14 - this is done
             *           to enable phone only bookings where during the booking attendee can provide only their phone number and not provide email, so you must pass to the email booking field {hidden: true, required: false}.
             *           If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            required?: Record<string, never>;
            /** @description Can be set to true only for organization team event types and if you also pass booking field {type: "phone", slug: "attendeePhoneNumber", required: true, hidden: false, label: "whatever label"} of booking field type PhoneFieldInput_2024_06_14 - this is done
             *           to enable phone only bookings where during the booking attendee can provide only their phone number and not provide email, so you must pass to the email booking field {hidden: true, required: false}.
             *           If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            placeholder: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&email=bob@gmail.com`,      the email field will be prefilled with this value and disabled. In case of Booker atom need to pass 'email' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{email: 'bob@gmail.com'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
        };
        TitleDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `title`
             * @example title
             */
            slug: string;
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&title=journey`,      the title field will be prefilled with this value and disabled. In case of Booker atom need to pass 'title' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{title: 'very important meeting'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
        };
        LocationDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `location`. This booking field is displayed only when event type has 2 or more locations in order to allow person doing the booking pick the location.
             * @example location
             */
            slug: string;
            label?: string;
        };
        NotesDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `notes`
             * @example notes
             */
            slug: string;
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&notes=journey`,      the notes field will be prefilled with this value and disabled. In case of Booker atom need to pass 'notes' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{notes: 'bring notebook and paper'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
        };
        GuestsDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `guests`
             * @example guests
             */
            slug: string;
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&guests=bob@cal.com`,      the guests field will be prefilled with this value and disabled. In case of Booker atom need to pass 'guests' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{guests: ['bob@gmail.com', 'alice@gmail.com']}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
        };
        RescheduleReasonDefaultFieldInput_2024_06_14: {
            /**
             * @description only allowed value for type is `rescheduleReason`
             * @example rescheduleReason
             */
            slug: string;
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&rescheduleReason=travel`,      the rescheduleReason field will be prefilled with this value and disabled. In case of Booker atom need to pass 'rescheduleReason' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{rescheduleReason: 'bob'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
        };
        InputOrganizersDefaultApp_2024_06_14: {
            /**
             * @description only allowed value for type is `organizersDefaultApp`
             * @example organizersDefaultApp
             */
            type: string;
        };
        CalVideoSettings: {
            /** @description If true, the organizer will not be able to record the meeting */
            disableRecordingForOrganizer?: boolean;
            /** @description If true, the guests will not be able to record the meeting */
            disableRecordingForGuests?: boolean;
            /** @description URL to which participants are redirected when they exit the call */
            redirectUrlOnExit?: Record<string, never>;
            /** @description If true, enables the automatic recording for the event when organizer joins the call */
            enableAutomaticRecordingForOrganizer?: boolean;
        };
        CreateEventTypeInput_2024_06_14: {
            /** @example 60 */
            lengthInMinutes: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: string[];
            /** @example Learn the secrets of masterchief! */
            title: string;
            /** @example learn-the-secrets-of-masterchief */
            slug: string;
            /** @example Discover the culinary wonders of the Argentina by making the best flan ever! */
            description?: string;
            /** @description Custom fields that can be added to the booking form when the event is booked by someone. By default booking form has name and email field. */
            bookingFields?: (components["schemas"]["NameDefaultFieldInput_2024_06_14"] | components["schemas"]["EmailDefaultFieldInput_2024_06_14"] | components["schemas"]["TitleDefaultFieldInput_2024_06_14"] | components["schemas"]["LocationDefaultFieldInput_2024_06_14"] | components["schemas"]["NotesDefaultFieldInput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldInput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldInput_2024_06_14"] | components["schemas"]["PhoneFieldInput_2024_06_14"] | components["schemas"]["AddressFieldInput_2024_06_14"] | components["schemas"]["TextFieldInput_2024_06_14"] | components["schemas"]["NumberFieldInput_2024_06_14"] | components["schemas"]["TextAreaFieldInput_2024_06_14"] | components["schemas"]["SelectFieldInput_2024_06_14"] | components["schemas"]["MultiSelectFieldInput_2024_06_14"] | components["schemas"]["MultiEmailFieldInput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldInput_2024_06_14"] | components["schemas"]["RadioGroupFieldInput_2024_06_14"] | components["schemas"]["BooleanFieldInput_2024_06_14"] | components["schemas"]["UrlFieldInput_2024_06_14"])[];
            /** @description If true, person booking this event can't add guests via their emails. */
            disableGuests?: boolean;
            /** @description Number representing length of each slot when event is booked. By default it equal length of the event type.
             *           If event length is 60 minutes then we would have slots 9AM, 10AM, 11AM etc. but if it was changed to 30 minutes then
             *           we would have slots 9AM, 9:30AM, 10AM, 10:30AM etc. as the available times to book the 60 minute event. */
            slotInterval?: number;
            /** @description Minimum number of minutes before the event that a booking can be made. */
            minimumBookingNotice?: number;
            /** @description Time spaces that can be prepended before an event to give more time before it. */
            beforeEventBuffer?: number;
            /** @description Time spaces that can be appended after an event to give more time after it. */
            afterEventBuffer?: number;
            /** @description If you want that this event has different schedule than user's default one you can specify it here. */
            scheduleId?: number;
            /** @description Limit how many times this event can be booked */
            bookingLimitsCount?: components["schemas"]["BaseBookingLimitsCount_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description This will limit your availability for this event type to one slot per day, scheduled at the earliest available time. */
            onlyShowFirstAvailableSlot?: boolean;
            /** @description Limit total amount of time that this event can be booked */
            bookingLimitsDuration?: components["schemas"]["BaseBookingLimitsDuration_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Offset timeslots shown to bookers by a specified number of minutes */
            offsetStart?: number;
            /** @description Should booker have week, month or column view. Specify default layout and enabled layouts user can pick. */
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            /** @description Specify how the booking needs to be manually confirmed before it is pushed to the integrations and a confirmation mail is sent. */
            confirmationPolicy?: components["schemas"]["BaseConfirmationPolicy_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Create a recurring event type. */
            recurrence?: components["schemas"]["Recurrence_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            lockTimeZoneToggleOnBookingPage?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            /** @description Create an event type with multiple seats. */
            seats?: components["schemas"]["Seats_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /**
             * @description Customizable event name with valid variables:
             *           {Event type title}, {Organiser}, {Scheduler}, {Location}, {Organiser first name},
             *           {Scheduler first name}, {Scheduler last name}, {Event duration}, {LOCATION},
             *           {HOST/ATTENDEE}, {HOST}, {ATTENDEE}, {USER}
             * @example {Event type title} between {Organiser} and {Scheduler}
             */
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /**
             * @description A valid URL where the booker will redirect to, once the booking is completed successfully
             * @example https://masterchief.com/argentina/flan/video/9129412
             */
            successRedirectUrl?: string;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"];
            /** @description Locations where the event will take place. If not provided, cal video link will be used as the location. */
            locations?: (components["schemas"]["InputAddressLocation_2024_06_14"] | components["schemas"]["InputLinkLocation_2024_06_14"] | components["schemas"]["InputIntegrationLocation_2024_06_14"] | components["schemas"]["InputPhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeAddressLocation_2024_06_14"] | components["schemas"]["InputAttendeePhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeDefinedLocation_2024_06_14"])[];
        };
        OutputAddressLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `address`
             * @example address
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp";
            /** @example 123 Example St, City, Country */
            address: string;
            public: boolean;
        };
        OutputLinkLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `link`
             * @example link
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp";
            /** @example https://customvideo.com/join/123456 */
            link: string;
            public: boolean;
        };
        OutputIntegrationLocation_2024_06_14: {
            /**
             * @description Only allowed value for type is `integration`
             * @example integration
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp" | "conferencing" | "unknown";
            /**
             * @example cal-video
             * @enum {string}
             */
            integration: "cal-video" | "google-meet" | "zoom" | "whereby-video" | "whatsapp-video" | "webex-video" | "telegram-video" | "tandem" | "sylaps-video" | "skype-video" | "sirius-video" | "signal-video" | "shimmer-video" | "salesroom-video" | "roam-video" | "riverside-video" | "ping-video" | "office365-video" | "mirotalk-video" | "jitsi" | "jelly-video" | "jelly-conferencing" | "huddle" | "facetime-video" | "element-call-video" | "eightxeight-video" | "discord-video" | "demodesk-video" | "campfire-video";
            /** @example https://example.com */
            link?: string;
            /** @description Credential ID associated with the integration */
            credentialId?: number;
        };
        OutputPhoneLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `phone`
             * @example phone
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp";
            /** @example +37120993151 */
            phone: string;
            public: boolean;
        };
        OutputOrganizersDefaultAppLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `organizersDefaultApp`
             * @example organizersDefaultApp
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp" | "conferencing" | "unknown";
        };
        OutputUnknownLocation_2024_06_14: {
            /**
             * @description only allowed value for type is `unknown`
             * @example unknown
             * @enum {string}
             */
            type: "address" | "link" | "integration" | "phone" | "attendeeAddress" | "attendeePhone" | "attendeeDefined" | "organizersDefaultApp" | "conferencing" | "unknown";
            location: string;
        };
        EmailDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `email`
             * @default email
             * @example email
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            label?: string;
            /**
             * @description Can be set to false only for organization team event types and if you also pass booking field {type: "phone", slug: "attendeePhoneNumber", required: true, hidden: false, label: "whatever label"} of booking field type PhoneFieldInput_2024_06_14 - this is done
             *           to enable phone only bookings where during the booking attendee can provide only their phone number and not provide email, so you must pass to the email booking field {hidden: true, required: false}.
             *           If true show under event type settings but don't show this booking field in the Booker. If false show in both.
             * @default true
             */
            required: Record<string, never>;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. Can only be hidden
             *           for organization team event types when also providing attendee phone number booking field. */
            hidden?: boolean;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&email=bob@gmail.com`,      the email field will be prefilled with this value and disabled. In case of Booker atom need to pass 'email' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{email: 'bob@gmail.com'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default email */
            slug: string;
        };
        NameDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `name`. Used for having 1 booking field for both first name and last name.
             * @default name
             * @example name
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&name=bob`,      the name field will be prefilled with this value and disabled. In case of Booker atom need to pass 'name' to defaultFormValues prop with the desired value e.g. `defaultFormValues={{name: 'bob'}}`. See guide https://cal.com/docs/platform/guides/booking-fields */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default name */
            slug: string;
            required: boolean;
        };
        LocationDefaultFieldOutput_2024_06_14: {
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /**
             * @description This booking field is returned only if the event type has more than one location. The purpose of this field is to allow the user to select the location where the event will take place.
             * @default location
             */
            slug: string;
            /** @default radioInput */
            type: string;
            required: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            label?: string;
        };
        RescheduleReasonDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `rescheduleReason`
             * @default rescheduleReason
             * @example rescheduleReason
             * @enum {string}
             */
            slug: "title" | "location" | "notes" | "guests" | "rescheduleReason";
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&rescheduleReason=busy`,      the reschedule reason field will be prefilled with this value and disabled. */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default textarea */
            type: string;
        };
        TitleDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `title`
             * @default title
             * @example title
             * @enum {string}
             */
            slug: "title" | "location" | "notes" | "guests" | "rescheduleReason";
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&title=masterclass`,      the title field will be prefilled with this value and disabled. */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default text */
            type: string;
        };
        NotesDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `notes`
             * @default notes
             * @example notes
             * @enum {string}
             */
            slug: "title" | "location" | "notes" | "guests" | "rescheduleReason";
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&notes=hello`,      the notes field will be prefilled with this value and disabled. */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default textarea */
            type: string;
        };
        GuestsDefaultFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `guests`
             * @default guests
             * @example guests
             * @enum {string}
             */
            slug: "title" | "location" | "notes" | "guests" | "rescheduleReason";
            required?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden?: boolean;
            label?: string;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if URL contains query parameter `&guests=lauris@cal.com`,      the guests field will be prefilled with this value and disabled. */
            disableOnPrefill?: boolean;
            /**
             * @description This property is always true because it's a default field
             * @default true
             * @example true
             */
            isDefault: Record<string, never>;
            /** @default multiemail */
            type: string;
        };
        AddressFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `address`
             * @example address
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your address */
            label: string;
            required: boolean;
            /** @example e.g., 1234 Main St */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `address` and the URL contains query parameter `&address=1234 Main St, London`,      the address field will be prefilled with this value and disabled.  In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{address: 'mainstreat 10, new york'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        BooleanFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `boolean`
             * @example boolean
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Agree to terms? */
            label: string;
            required: boolean;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `notify` and the URL contains query parameter `&notify=true`,      the checkbox will be selected and the checkbox field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{notify: true}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        CheckboxGroupFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `checkbox`
             * @example checkbox
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Select all that apply */
            label: string;
            required: boolean;
            /** @example [
             *       "Checkbox 1",
             *       "Checkbox 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `notify` and the URL contains query parameter `&notify=true`,      the checkbox will be selected and the checkbox field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{notify: true}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        MultiEmailFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `multiemail`
             * @example multiemail
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter multiple emails */
            label: string;
            required: boolean;
            /** @example e.g., example@example.com */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `consultants` and the URL contains query parameter `&consultants=alice@gmail.com&consultants=bob@gmail.com`,      the these emails will be added and none more can be added. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{consultants: ['alice@gmail.com', 'bob@gmail.com']}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        MultiSelectFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `multiselect`
             * @example multiselect
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please select multiple options */
            label: string;
            required: boolean;
            /** @example [
             *       "Option 1",
             *       "Option 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and the URL contains query parameter `&language=en&language=it`,      the 'en' and 'it' will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: ['en', 'it']}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        UrlFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `url`
             * @example url
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your text */
            label: string;
            required: boolean;
            /** @example e.g., Enter url here */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `videourl` and the URL contains query parameter `&videourl=https://youtube.com/abc`the url field will be prefilled with this value and disabled.       In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{videourl: 'https://caltube.com/123'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        NumberFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `number`
             * @example number
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter a number */
            label: string;
            required: boolean;
            /** @example e.g., 100 */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `calories` and the URL contains query parameter `&calories=3000`,      the number field will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{calories: 3000}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        PhoneFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `phone`
             * @example phone
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking. Special slug is `attendeePhoneNumber` - if you create
             *           a phone input field with this slug for organization team event type you can create an organization team event type that can be booked using phone without requiring an email by setting {"type": "email", "required": false, "hidden": true} to the email booking field input in the request body.
             * @example some-slug
             */
            slug: string;
            label: string;
            required: boolean;
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `phone` and the URL contains query parameter `&phone=1234567890`,      the phone field will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{phone: '+37122222222'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        RadioGroupFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `radio`
             * @example radio
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Select one option */
            label: string;
            required: boolean;
            /** @example [
             *       "Radio 1",
             *       "Radio 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and options of this select field are ['english', 'italian'] and the URL contains query parameter `&language=italian`,      the 'italian' radio button will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: 'italian'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        SelectFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `select`
             * @example select
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please select an option */
            label: string;
            required: boolean;
            /** @example Select... */
            placeholder?: string;
            /** @example [
             *       "Option 1",
             *       "Option 2"
             *     ] */
            options: string[];
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `language` and options of this select field are ['english', 'italian'] and the URL contains query parameter `&language=italian`,      the 'italian' will be selected and the select field will be disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{language: 'italian'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        TextAreaFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `textarea`
             * @example textarea
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter detailed information */
            label: string;
            required: boolean;
            /** @example e.g., Detailed description here... */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `reflection` and the URL contains query parameter `&reflection=Today I shipped a feature`,      the text area will be prefilled with this value and disabled. In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value  e.g. `defaultFormValues={{reflection: 'Today i shipped a feature'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        TextFieldOutput_2024_06_14: {
            /**
             * @description only allowed value for type is `text`
             * @example text
             * @enum {string}
             */
            type: "name" | "email" | "phone" | "address" | "text" | "number" | "textarea" | "select" | "multiselect" | "multiemail" | "checkbox" | "radio" | "boolean" | "url";
            /**
             * @description Unique identifier for the field in format `some-slug`. It is used to access response to this booking field during the booking
             * @example some-slug
             */
            slug: string;
            /** @example Please enter your text */
            label: string;
            required: boolean;
            /** @example e.g., Enter text here */
            placeholder?: string;
            /** @description Disable this booking field if the URL contains query parameter with key equal to the slug and prefill it with the provided value.      For example, if the slug is `friend` and the URL contains query parameter `&friend=bob`,      the text field will be prefilled with this value and disabled.  In case of Booker atom need to pass slug you used for this booking field to defaultFormValues prop with the desired value e.g. `defaultFormValues={{friend: 'bob'}}`. See guide https://cal.com/docs/platform/guides/booking-field */
            disableOnPrefill?: boolean;
            /** @description If true show under event type settings but don't show this booking field in the Booker. If false show in both. */
            hidden: boolean;
            /**
             * @description This property is always false because it's not default field but custom field
             * @default false
             * @example false
             */
            isDefault: Record<string, never>;
        };
        EventTypeOutput_2024_06_14: {
            /** @example 1 */
            id: number;
            /** @example 60 */
            lengthInMinutes: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: number[];
            /** @example Learn the secrets of masterchief! */
            title: string;
            /** @example learn-the-secrets-of-masterchief */
            slug: string;
            /** @example Discover the culinary wonders of Argentina by making the best flan ever! */
            description: string;
            locations: (components["schemas"]["OutputAddressLocation_2024_06_14"] | components["schemas"]["OutputLinkLocation_2024_06_14"] | components["schemas"]["OutputIntegrationLocation_2024_06_14"] | components["schemas"]["OutputPhoneLocation_2024_06_14"] | components["schemas"]["OutputOrganizersDefaultAppLocation_2024_06_14"] | components["schemas"]["OutputUnknownLocation_2024_06_14"])[];
            bookingFields: (components["schemas"]["NameDefaultFieldOutput_2024_06_14"] | components["schemas"]["EmailDefaultFieldOutput_2024_06_14"] | components["schemas"]["LocationDefaultFieldOutput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldOutput_2024_06_14"] | components["schemas"]["TitleDefaultFieldOutput_2024_06_14"] | components["schemas"]["NotesDefaultFieldOutput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldOutput_2024_06_14"] | components["schemas"]["PhoneFieldOutput_2024_06_14"] | components["schemas"]["AddressFieldOutput_2024_06_14"] | components["schemas"]["TextFieldOutput_2024_06_14"] | components["schemas"]["NumberFieldOutput_2024_06_14"] | components["schemas"]["TextAreaFieldOutput_2024_06_14"] | components["schemas"]["SelectFieldOutput_2024_06_14"] | components["schemas"]["MultiSelectFieldOutput_2024_06_14"] | components["schemas"]["MultiEmailFieldOutput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldOutput_2024_06_14"] | components["schemas"]["RadioGroupFieldOutput_2024_06_14"] | components["schemas"]["BooleanFieldOutput_2024_06_14"] | components["schemas"]["UrlFieldOutput_2024_06_14"])[];
            disableGuests: boolean;
            /** @example 60 */
            slotInterval?: Record<string, never> | null;
            /** @example 0 */
            minimumBookingNotice?: number;
            /** @example 0 */
            beforeEventBuffer?: number;
            /** @example 0 */
            afterEventBuffer?: number;
            recurrence: components["schemas"]["Recurrence_2024_06_14"] | null;
            metadata: Record<string, never>;
            price: number;
            currency: string;
            lockTimeZoneToggleOnBookingPage: boolean;
            seatsPerTimeSlot?: Record<string, never> | null;
            forwardParamsSuccessRedirect: Record<string, never> | null;
            successRedirectUrl: Record<string, never> | null;
            isInstantEvent: boolean;
            seatsShowAvailabilityCount?: boolean | null;
            scheduleId: number | null;
            bookingLimitsCount?: Record<string, never>;
            onlyShowFirstAvailableSlot?: boolean;
            bookingLimitsDuration?: Record<string, never>;
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: (components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"])[];
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            confirmationPolicy?: Record<string, never>;
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            seats?: components["schemas"]["Seats_2024_06_14"];
            offsetStart?: number;
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"];
            /** @example 10 */
            ownerId: number;
            users: string[];
        };
        CreateEventTypeOutput_2024_06_14: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeOutput_2024_06_14"];
        };
        GetEventTypeOutput_2024_06_14: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeOutput_2024_06_14"] | null;
        };
        GetEventTypesOutput_2024_06_14: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeOutput_2024_06_14"][];
        };
        UpdateEventTypeInput_2024_06_14: {
            /** @example 60 */
            lengthInMinutes?: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: string[];
            /** @example Learn the secrets of masterchief! */
            title?: string;
            /** @example learn-the-secrets-of-masterchief */
            slug?: string;
            /** @example Discover the culinary wonders of the Argentina by making the best flan ever! */
            description?: string;
            /** @description Complete set of booking form fields. This array replaces all existing booking fields. To modify existing fields, first fetch the current event type, then include all desired fields in this array. Sending only one field will remove all other custom fields, keeping only default fields plus the provided one. */
            bookingFields?: (components["schemas"]["NameDefaultFieldInput_2024_06_14"] | components["schemas"]["EmailDefaultFieldInput_2024_06_14"] | components["schemas"]["TitleDefaultFieldInput_2024_06_14"] | components["schemas"]["LocationDefaultFieldInput_2024_06_14"] | components["schemas"]["NotesDefaultFieldInput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldInput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldInput_2024_06_14"] | components["schemas"]["PhoneFieldInput_2024_06_14"] | components["schemas"]["AddressFieldInput_2024_06_14"] | components["schemas"]["TextFieldInput_2024_06_14"] | components["schemas"]["NumberFieldInput_2024_06_14"] | components["schemas"]["TextAreaFieldInput_2024_06_14"] | components["schemas"]["SelectFieldInput_2024_06_14"] | components["schemas"]["MultiSelectFieldInput_2024_06_14"] | components["schemas"]["MultiEmailFieldInput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldInput_2024_06_14"] | components["schemas"]["RadioGroupFieldInput_2024_06_14"] | components["schemas"]["BooleanFieldInput_2024_06_14"])[];
            /** @description If true, person booking this event can't add guests via their emails. */
            disableGuests?: boolean;
            /** @description Number representing length of each slot when event is booked. By default it equal length of the event type.
             *           If event length is 60 minutes then we would have slots 9AM, 10AM, 11AM etc. but if it was changed to 30 minutes then
             *           we would have slots 9AM, 9:30AM, 10AM, 10:30AM etc. as the available times to book the 60 minute event. */
            slotInterval?: number;
            /** @description Minimum number of minutes before the event that a booking can be made. */
            minimumBookingNotice?: number;
            /** @description Time spaces that can be prepended before an event to give more time before it. */
            beforeEventBuffer?: number;
            /** @description Time spaces that can be appended after an event to give more time after it. */
            afterEventBuffer?: number;
            /** @description If you want that this event has different schedule than user's default one you can specify it here. */
            scheduleId?: number;
            /** @description Limit how many times this event can be booked */
            bookingLimitsCount?: components["schemas"]["BaseBookingLimitsCount_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description This will limit your availability for this event type to one slot per day, scheduled at the earliest available time. */
            onlyShowFirstAvailableSlot?: boolean;
            /** @description Limit total amount of time that this event can be booked */
            bookingLimitsDuration?: components["schemas"]["BaseBookingLimitsDuration_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Offset timeslots shown to bookers by a specified number of minutes */
            offsetStart?: number;
            /** @description Should booker have week, month or column view. Specify default layout and enabled layouts user can pick. */
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            /** @description Specify how the booking needs to be manually confirmed before it is pushed to the integrations and a confirmation mail is sent. */
            confirmationPolicy?: components["schemas"]["BaseConfirmationPolicy_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Create a recurring event type. */
            recurrence?: components["schemas"]["Recurrence_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            lockTimeZoneToggleOnBookingPage?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            /** @description Create an event type with multiple seats. */
            seats?: components["schemas"]["Seats_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /**
             * @description Customizable event name with valid variables:
             *           {Event type title}, {Organiser}, {Scheduler}, {Location}, {Organiser first name},
             *           {Scheduler first name}, {Scheduler last name}, {Event duration}, {LOCATION},
             *           {HOST/ATTENDEE}, {HOST}, {ATTENDEE}, {USER}
             * @example {Event type title} between {Organiser} and {Scheduler}
             */
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /**
             * @description A valid URL where the booker will redirect to, once the booking is completed successfully
             * @example https://masterchief.com/argentina/flan/video/9129412
             */
            successRedirectUrl?: string;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"];
            /** @description Locations where the event will take place. If not provided, cal video link will be used as the location. */
            locations?: (components["schemas"]["InputAddressLocation_2024_06_14"] | components["schemas"]["InputLinkLocation_2024_06_14"] | components["schemas"]["InputIntegrationLocation_2024_06_14"] | components["schemas"]["InputPhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeAddressLocation_2024_06_14"] | components["schemas"]["InputAttendeePhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeDefinedLocation_2024_06_14"])[];
        };
        UpdateEventTypeOutput_2024_06_14: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeOutput_2024_06_14"];
        };
        DeleteData_2024_06_14: {
            /** @example 1 */
            id: number;
            /** @example 60 */
            lengthInMinutes: number;
            /** @example Learn the secrets of masterchief! */
            title: string;
            slug: string;
        };
        DeleteEventTypeOutput_2024_06_14: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["DeleteData_2024_06_14"];
        };
        SelectedCalendarsInputDto: {
            integration: string;
            externalId: string;
            credentialId: number;
            delegationCredentialId?: string;
        };
        SelectedCalendarOutputDto: {
            userId: number;
            integration: string;
            externalId: string;
            credentialId: number | null;
        };
        SelectedCalendarOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["SelectedCalendarOutputDto"];
        };
        OrgTeamOutputDto: {
            id: number;
            parentId?: number;
            name: string;
            slug?: string;
            logoUrl?: string;
            calVideoLogo?: string;
            appLogo?: string;
            appIconLogo?: string;
            bio?: string;
            hideBranding?: boolean;
            isOrganization: boolean;
            isPrivate?: boolean;
            /** @default false */
            hideBookATeamMember: boolean;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            theme?: string;
            brandColor?: string;
            darkBrandColor?: string;
            bannerUrl?: string;
            timeFormat?: number;
            /** @default Europe/London */
            timeZone: string;
            /** @default Sunday */
            weekStart: string;
        };
        OrgTeamsOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrgTeamOutputDto"][];
        };
        OrgMeTeamsOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrgTeamOutputDto"][];
        };
        OrgTeamOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrgTeamOutputDto"];
        };
        UpdateOrgTeamDto: {
            /**
             * @description Name of the team
             * @example CalTeam
             */
            name?: string;
            /**
             * @description Team slug
             * @example caltel
             */
            slug?: string;
            /**
             * @description URL of the teams logo image
             * @example https://i.cal.com/api/avatar/b0b58752-68ad-4c0d-8024-4fa382a77752.png
             */
            logoUrl?: string;
            calVideoLogo?: string;
            appLogo?: string;
            appIconLogo?: string;
            bio?: string;
            hideBranding?: boolean;
            isPrivate?: boolean;
            hideBookATeamMember?: boolean;
            /**
             * @description You can store any additional data you want here.
             *     Metadata must have at most 50 keys, each key up to 40 characters.
             *     Values can be strings (up to 500 characters), numbers, or booleans.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            theme?: string;
            brandColor?: string;
            darkBrandColor?: string;
            /**
             * @description URL of the teams banner image which is shown on booker
             * @example https://i.cal.com/api/avatar/949be534-7a88-4185-967c-c020b0c0bef3.png
             */
            bannerUrl?: string;
            timeFormat?: number;
            /**
             * @description Timezone is used to create teams's default schedule from Monday to Friday from 9AM to 5PM. It will default to Europe/London if not passed.
             * @example America/New_York
             */
            timeZone?: string;
            /** @example Monday */
            weekStart?: string;
            bookingLimits?: string;
            includeManagedEventsInLimits?: boolean;
        };
        CreateOrgTeamDto: {
            /**
             * @description Name of the team
             * @example CalTeam
             */
            name: string;
            /**
             * @description Team slug in kebab-case - if not provided will be generated automatically based on name.
             * @example caltel
             */
            slug?: string;
            /**
             * @description URL of the teams logo image
             * @example https://i.cal.com/api/avatar/b0b58752-68ad-4c0d-8024-4fa382a77752.png
             */
            logoUrl?: string;
            calVideoLogo?: string;
            appLogo?: string;
            appIconLogo?: string;
            bio?: string;
            /** @default false */
            hideBranding: boolean;
            isPrivate?: boolean;
            hideBookATeamMember?: boolean;
            /**
             * @description You can store any additional data you want here.
             *     Metadata must have at most 50 keys, each key up to 40 characters.
             *     Values can be strings (up to 500 characters), numbers, or booleans.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            theme?: string;
            brandColor?: string;
            darkBrandColor?: string;
            /**
             * @description URL of the teams banner image which is shown on booker
             * @example https://i.cal.com/api/avatar/949be534-7a88-4185-967c-c020b0c0bef3.png
             */
            bannerUrl?: string;
            timeFormat?: number;
            /**
             * @description Timezone is used to create teams's default schedule from Monday to Friday from 9AM to 5PM. It will default to Europe/London if not passed.
             * @default Europe/London
             * @example America/New_York
             */
            timeZone: string;
            /**
             * @default Sunday
             * @example Monday
             */
            weekStart: string;
            /**
             * @description If you are a platform customer, don't pass 'false', because then team creator won't be able to create team event types.
             * @default true
             */
            autoAcceptCreator: boolean;
        };
        ScheduleAvailabilityInput_2024_06_11: {
            /**
             * @description Array of days when schedule is active.
             * @example [
             *       "Monday",
             *       "Tuesday"
             *     ]
             * @enum {array}
             */
            days: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";
            /**
             * @description startTime must be a valid time in format HH:MM e.g. 08:00
             * @example 08:00
             */
            startTime: string;
            /**
             * @description endTime must be a valid time in format HH:MM e.g. 15:00
             * @example 15:00
             */
            endTime: string;
        };
        ScheduleOverrideInput_2024_06_11: {
            /** @example 2024-05-20 */
            date: string;
            /**
             * @description startTime must be a valid time in format HH:MM e.g. 12:00
             * @example 12:00
             */
            startTime: string;
            /**
             * @description endTime must be a valid time in format HH:MM e.g. 13:00
             * @example 13:00
             */
            endTime: string;
        };
        ScheduleOutput_2024_06_11: {
            /** @example 254 */
            id: number;
            /** @example 478 */
            ownerId: number;
            /** @example Catch up hours */
            name: string;
            /** @example Europe/Rome */
            timeZone: string;
            /** @example [
             *       {
             *         "days": [
             *           "Monday",
             *           "Tuesday"
             *         ],
             *         "startTime": "17:00",
             *         "endTime": "19:00"
             *       },
             *       {
             *         "days": [
             *           "Wednesday",
             *           "Thursday"
             *         ],
             *         "startTime": "16:00",
             *         "endTime": "20:00"
             *       }
             *     ] */
            availability: components["schemas"]["ScheduleAvailabilityInput_2024_06_11"][];
            /** @example true */
            isDefault: boolean;
            /** @example [
             *       {
             *         "date": "2024-05-20",
             *         "startTime": "18:00",
             *         "endTime": "21:00"
             *       }
             *     ] */
            overrides: components["schemas"]["ScheduleOverrideInput_2024_06_11"][];
        };
        GetSchedulesOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput_2024_06_11"][];
            error?: Record<string, never>;
        };
        CreateScheduleInput_2024_06_11: {
            /** @example Catch up hours */
            name: string;
            /**
             * @description Timezone is used to calculate available times when an event using the schedule is booked.
             * @example Europe/Rome
             */
            timeZone: string;
            /**
             * @description Each object contains days and times when the user is available. If not passed, the default availability is Monday to Friday from 09:00 to 17:00.
             * @example [
             *       {
             *         "days": [
             *           "Monday",
             *           "Tuesday"
             *         ],
             *         "startTime": "17:00",
             *         "endTime": "19:00"
             *       },
             *       {
             *         "days": [
             *           "Wednesday",
             *           "Thursday"
             *         ],
             *         "startTime": "16:00",
             *         "endTime": "20:00"
             *       }
             *     ]
             */
            availability?: components["schemas"]["ScheduleAvailabilityInput_2024_06_11"][];
            /**
             * @description Each user should have 1 default schedule. If you specified `timeZone` when creating managed user, then the default schedule will be created with that timezone.
             *         Default schedule means that if an event type is not tied to a specific schedule then the default schedule is used.
             * @example true
             */
            isDefault: boolean;
            /**
             * @description Need to change availability for a specific date? Add an override.
             * @example [
             *       {
             *         "date": "2024-05-20",
             *         "startTime": "18:00",
             *         "endTime": "21:00"
             *       }
             *     ]
             */
            overrides?: components["schemas"]["ScheduleOverrideInput_2024_06_11"][];
        };
        CreateScheduleOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput_2024_06_11"];
        };
        GetScheduleOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput_2024_06_11"] | null;
            error?: Record<string, never>;
        };
        UpdateScheduleInput_2024_06_11: {
            /** @example One-on-one coaching */
            name?: string;
            /** @example Europe/Rome */
            timeZone?: string;
            /** @example [
             *       {
             *         "days": [
             *           "Monday",
             *           "Tuesday"
             *         ],
             *         "startTime": "09:00",
             *         "endTime": "10:00"
             *       }
             *     ] */
            availability?: components["schemas"]["ScheduleAvailabilityInput_2024_06_11"][];
            /** @example true */
            isDefault?: boolean;
            /** @example [
             *       {
             *         "date": "2024-05-20",
             *         "startTime": "12:00",
             *         "endTime": "14:00"
             *       }
             *     ] */
            overrides?: components["schemas"]["ScheduleOverrideInput_2024_06_11"][];
        };
        UpdateScheduleOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput_2024_06_11"];
            error?: Record<string, never>;
        };
        DeleteScheduleOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        ProfileOutput: {
            /**
             * @description The ID of the profile of user
             * @example 1
             */
            id: number;
            /**
             * @description The ID of the organization of user
             * @example 1
             */
            organizationId: number;
            /**
             * @description The IDof the user
             * @example 1
             */
            userId: number;
            /**
             * @description The username of the user within the organization context
             * @example john_doe
             */
            username?: string | null;
        };
        GetOrgUsersWithProfileOutput: {
            /**
             * @description The ID of the user
             * @example 1
             */
            id: number;
            /**
             * @description The username of the user
             * @example john_doe
             */
            username?: string | null;
            /**
             * @description The name of the user
             * @example John Doe
             */
            name?: string | null;
            /**
             * @description The email of the user
             * @example john@example.com
             */
            email: string;
            /**
             * Format: date-time
             * @description The date when the email was verified
             * @example 2022-01-01T00:00:00Z
             */
            emailVerified?: string | null;
            /**
             * @description The bio of the user
             * @example I am a software developer
             */
            bio?: string | null;
            /**
             * @description The URL of the user's avatar
             * @example https://example.com/avatar.jpg
             */
            avatarUrl?: string | null;
            /**
             * @description The time zone of the user
             * @example America/New_York
             */
            timeZone: string;
            /**
             * @description The week start day of the user
             * @example Monday
             */
            weekStart: string;
            /**
             * @description The app theme of the user
             * @example light
             */
            appTheme?: string | null;
            /**
             * @description The theme of the user
             * @example default
             */
            theme?: string | null;
            /**
             * @description The ID of the default schedule for the user
             * @example 1
             */
            defaultScheduleId?: number | null;
            /**
             * @description The locale of the user
             * @example en-US
             */
            locale?: string | null;
            /**
             * @description The time format of the user
             * @example 12
             */
            timeFormat?: number | null;
            /**
             * @description Whether to hide branding for the user
             * @example false
             */
            hideBranding: boolean;
            /**
             * @description The brand color of the user
             * @example #ffffff
             */
            brandColor?: string | null;
            /**
             * @description The dark brand color of the user
             * @example #000000
             */
            darkBrandColor?: string | null;
            /**
             * @description Whether dynamic booking is allowed for the user
             * @example true
             */
            allowDynamicBooking?: boolean | null;
            /**
             * Format: date-time
             * @description The date when the user was created
             * @example 2022-01-01T00:00:00Z
             */
            createdDate: string;
            /**
             * @description Whether the user is verified
             * @example true
             */
            verified?: boolean | null;
            /**
             * @description The ID of the user who invited this user
             * @example 1
             */
            invitedTo?: number | null;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @description organization user profile, contains user data within the organizaton context */
            profile: components["schemas"]["ProfileOutput"];
        };
        GetOrganizationUsersResponseDTO: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["GetOrgUsersWithProfileOutput"][];
        };
        CreateOrganizationUserInput: {
            /**
             * @description User email address
             * @example user@example.com
             */
            email: string;
            /**
             * @description Username
             * @example user123
             */
            username?: string;
            /**
             * @description Preferred weekday
             * @example Monday
             */
            weekday?: string;
            /**
             * @description Brand color in HEX format
             * @example #FFFFFF
             */
            brandColor?: string;
            /**
             * @description Bio
             * @example I am a bio
             */
            bio?: string;
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            /**
             * @description Dark brand color in HEX format
             * @example #000000
             */
            darkBrandColor?: string;
            /**
             * @description Hide branding
             * @example false
             */
            hideBranding?: boolean;
            /**
             * @description Time zone
             * @example America/New_York
             */
            timeZone?: string;
            /**
             * @description Theme
             * @example dark
             */
            theme?: string | null;
            /**
             * @description Application theme
             * @example light
             */
            appTheme?: string | null;
            /**
             * @description Time format
             * @example 24
             */
            timeFormat?: number;
            /**
             * @description Default schedule ID
             * @example 1
             */
            defaultScheduleId?: number;
            /**
             * @description Locale
             * @default en
             * @example en
             */
            locale: string | null;
            /**
             * @description Avatar URL
             * @example https://example.com/avatar.jpg
             */
            avatarUrl?: string;
            /**
             * @default MEMBER
             * @enum {string}
             */
            organizationRole: "MEMBER" | "ADMIN" | "OWNER";
            /** @default true */
            autoAccept: boolean;
        };
        GetOrganizationUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["GetOrgUsersWithProfileOutput"];
        };
        UpdateOrganizationUserInput: Record<string, never>;
        BaseAttribute: {
            id: string;
            name: string;
        };
        TextAttribute: {
            id: string;
            name: string;
            type: string;
            option: string;
            optionId: string;
        };
        NumberAttribute: {
            id: string;
            name: string;
            type: string;
            option: number;
            optionId: string;
        };
        SingleSelectAttribute: {
            id: string;
            name: string;
            type: string;
            option: string;
            optionId: string;
        };
        MultiSelectAttributeOption: {
            optionId: string;
            option: string;
        };
        MultiSelectAttribute: {
            id: string;
            name: string;
            type: string;
            options: components["schemas"]["MultiSelectAttributeOption"][];
        };
        MembershipUserOutputDto: {
            avatarUrl?: string;
            username?: string;
            name?: string;
            email: string;
            bio?: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
        };
        OrganizationMembershipOutput: {
            id: number;
            userId: number;
            teamId: number;
            accepted: boolean;
            /** @enum {string} */
            role: "MEMBER" | "OWNER" | "ADMIN";
            disableImpersonation?: boolean;
            user: components["schemas"]["MembershipUserOutputDto"];
            attributes: (components["schemas"]["TextAttribute"] | components["schemas"]["NumberAttribute"] | components["schemas"]["SingleSelectAttribute"] | components["schemas"]["MultiSelectAttribute"])[];
        };
        GetAllOrgMemberships: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrganizationMembershipOutput"];
        };
        CreateOrgMembershipDto: {
            userId: number;
            /** @default false */
            accepted: boolean;
            /**
             * @description If you are platform customer then managed users should only have MEMBER role.
             * @default MEMBER
             * @enum {string}
             */
            role: "MEMBER" | "OWNER" | "ADMIN";
            /** @default false */
            disableImpersonation: boolean;
        };
        CreateOrgMembershipOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrganizationMembershipOutput"];
        };
        GetOrgMembership: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrganizationMembershipOutput"];
        };
        DeleteOrgMembership: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrganizationMembershipOutput"];
        };
        UpdateOrgMembershipDto: {
            accepted?: boolean;
            /** @enum {string} */
            role?: "MEMBER" | "OWNER" | "ADMIN";
            disableImpersonation?: boolean;
        };
        UpdateOrgMembership: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OrganizationMembershipOutput"];
        };
        Host: {
            /** @description Which user is the host of this event */
            userId: number;
            /** @description Only relevant for round robin event types. If true then the user must attend round robin event always. */
            mandatory?: boolean;
            /** @enum {string} */
            priority?: "lowest" | "low" | "medium" | "high" | "highest";
        };
        CreateTeamEventTypeInput_2024_06_14: {
            /** @example 60 */
            lengthInMinutes: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: string[];
            /** @example Learn the secrets of masterchief! */
            title: string;
            /** @example learn-the-secrets-of-masterchief */
            slug: string;
            /** @example Discover the culinary wonders of the Argentina by making the best flan ever! */
            description?: string;
            /** @description Custom fields that can be added to the booking form when the event is booked by someone. By default booking form has name and email field. */
            bookingFields?: (components["schemas"]["NameDefaultFieldInput_2024_06_14"] | components["schemas"]["EmailDefaultFieldInput_2024_06_14"] | components["schemas"]["TitleDefaultFieldInput_2024_06_14"] | components["schemas"]["LocationDefaultFieldInput_2024_06_14"] | components["schemas"]["NotesDefaultFieldInput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldInput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldInput_2024_06_14"] | components["schemas"]["PhoneFieldInput_2024_06_14"] | components["schemas"]["AddressFieldInput_2024_06_14"] | components["schemas"]["TextFieldInput_2024_06_14"] | components["schemas"]["NumberFieldInput_2024_06_14"] | components["schemas"]["TextAreaFieldInput_2024_06_14"] | components["schemas"]["SelectFieldInput_2024_06_14"] | components["schemas"]["MultiSelectFieldInput_2024_06_14"] | components["schemas"]["MultiEmailFieldInput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldInput_2024_06_14"] | components["schemas"]["RadioGroupFieldInput_2024_06_14"] | components["schemas"]["BooleanFieldInput_2024_06_14"] | components["schemas"]["UrlFieldInput_2024_06_14"])[];
            /** @description If true, person booking this event can't add guests via their emails. */
            disableGuests?: boolean;
            /** @description Number representing length of each slot when event is booked. By default it equal length of the event type.
             *           If event length is 60 minutes then we would have slots 9AM, 10AM, 11AM etc. but if it was changed to 30 minutes then
             *           we would have slots 9AM, 9:30AM, 10AM, 10:30AM etc. as the available times to book the 60 minute event. */
            slotInterval?: number;
            /** @description Minimum number of minutes before the event that a booking can be made. */
            minimumBookingNotice?: number;
            /** @description Time spaces that can be prepended before an event to give more time before it. */
            beforeEventBuffer?: number;
            /** @description Time spaces that can be appended after an event to give more time after it. */
            afterEventBuffer?: number;
            /** @description If you want that this event has different schedule than user's default one you can specify it here. */
            scheduleId?: number;
            /** @description Limit how many times this event can be booked */
            bookingLimitsCount?: components["schemas"]["BaseBookingLimitsCount_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description This will limit your availability for this event type to one slot per day, scheduled at the earliest available time. */
            onlyShowFirstAvailableSlot?: boolean;
            /** @description Limit total amount of time that this event can be booked */
            bookingLimitsDuration?: components["schemas"]["BaseBookingLimitsDuration_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Offset timeslots shown to bookers by a specified number of minutes */
            offsetStart?: number;
            /** @description Should booker have week, month or column view. Specify default layout and enabled layouts user can pick. */
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            /** @description Specify how the booking needs to be manually confirmed before it is pushed to the integrations and a confirmation mail is sent. */
            confirmationPolicy?: components["schemas"]["BaseConfirmationPolicy_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Create a recurring event type. */
            recurrence?: components["schemas"]["Recurrence_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            lockTimeZoneToggleOnBookingPage?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            /** @description Create an event type with multiple seats. */
            seats?: components["schemas"]["Seats_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /**
             * @description Customizable event name with valid variables:
             *           {Event type title}, {Organiser}, {Scheduler}, {Location}, {Organiser first name},
             *           {Scheduler first name}, {Scheduler last name}, {Event duration}, {LOCATION},
             *           {HOST/ATTENDEE}, {HOST}, {ATTENDEE}, {USER}
             * @example {Event type title} between {Organiser} and {Scheduler}
             */
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /**
             * @description A valid URL where the booker will redirect to, once the booking is completed successfully
             * @example https://masterchief.com/argentina/flan/video/9129412
             */
            successRedirectUrl?: string;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"];
            /**
             * @description The scheduling type for the team event - collective, roundRobin or managed.
             * @example collective
             * @enum {string}
             */
            schedulingType: "collective" | "roundRobin" | "managed";
            /** @description Hosts contain specific team members you want to assign to this event type, but if you want to assign all team members, use `assignAllTeamMembers: true` instead and omit this field. For platform customers the hosts can include userIds only of managed users. */
            hosts?: components["schemas"]["Host"][];
            /** @description If true, all current and future team members will be assigned to this event type */
            assignAllTeamMembers?: boolean;
            /** @description Locations where the event will take place. If not provided, cal video link will be used as the location. */
            locations?: (components["schemas"]["InputAddressLocation_2024_06_14"] | components["schemas"]["InputLinkLocation_2024_06_14"] | components["schemas"]["InputIntegrationLocation_2024_06_14"] | components["schemas"]["InputPhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeAddressLocation_2024_06_14"] | components["schemas"]["InputAttendeePhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeDefinedLocation_2024_06_14"] | components["schemas"]["InputOrganizersDefaultApp_2024_06_14"])[];
        };
        CreateTeamEventTypeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamEventTypeOutput_2024_06_14"] | components["schemas"]["TeamEventTypeOutput_2024_06_14"][];
        };
        TeamEventTypeResponseHost: {
            /** @description Which user is the host of this event */
            userId: number;
            /**
             * @description Only relevant for round robin event types. If true then the user must attend round robin event always.
             * @default false
             */
            mandatory: boolean;
            /**
             * @default medium
             * @enum {string}
             */
            priority: "lowest" | "low" | "medium" | "high" | "highest";
            /** @example John Doe */
            name: string;
            /** @example john-doe */
            username: string;
            /** @example https://cal.com/api/avatar/d95949bc-ccb1-400f-acf6-045c51a16856.png */
            avatarUrl?: string | null;
        };
        EventTypeTeam: {
            id: number;
            slug?: string;
            bannerUrl?: string;
            name?: string;
            logoUrl?: string;
            weekStart?: string;
            brandColor?: string;
            darkBrandColor?: string;
            theme?: string;
        };
        TeamEventTypeOutput_2024_06_14: {
            /** @example 1 */
            id: number;
            /** @example 60 */
            lengthInMinutes: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: number[];
            /** @example Learn the secrets of masterchief! */
            title: string;
            /** @example learn-the-secrets-of-masterchief */
            slug: string;
            /** @example Discover the culinary wonders of Argentina by making the best flan ever! */
            description: string;
            locations: (components["schemas"]["OutputAddressLocation_2024_06_14"] | components["schemas"]["OutputLinkLocation_2024_06_14"] | components["schemas"]["OutputIntegrationLocation_2024_06_14"] | components["schemas"]["OutputPhoneLocation_2024_06_14"] | components["schemas"]["OutputOrganizersDefaultAppLocation_2024_06_14"] | components["schemas"]["OutputUnknownLocation_2024_06_14"])[];
            bookingFields: (components["schemas"]["NameDefaultFieldOutput_2024_06_14"] | components["schemas"]["EmailDefaultFieldOutput_2024_06_14"] | components["schemas"]["LocationDefaultFieldOutput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldOutput_2024_06_14"] | components["schemas"]["TitleDefaultFieldOutput_2024_06_14"] | components["schemas"]["NotesDefaultFieldOutput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldOutput_2024_06_14"] | components["schemas"]["PhoneFieldOutput_2024_06_14"] | components["schemas"]["AddressFieldOutput_2024_06_14"] | components["schemas"]["TextFieldOutput_2024_06_14"] | components["schemas"]["NumberFieldOutput_2024_06_14"] | components["schemas"]["TextAreaFieldOutput_2024_06_14"] | components["schemas"]["SelectFieldOutput_2024_06_14"] | components["schemas"]["MultiSelectFieldOutput_2024_06_14"] | components["schemas"]["MultiEmailFieldOutput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldOutput_2024_06_14"] | components["schemas"]["RadioGroupFieldOutput_2024_06_14"] | components["schemas"]["BooleanFieldOutput_2024_06_14"] | components["schemas"]["UrlFieldOutput_2024_06_14"])[];
            disableGuests: boolean;
            /** @example 60 */
            slotInterval?: number | null;
            /** @example 0 */
            minimumBookingNotice?: number;
            /** @example 0 */
            beforeEventBuffer?: number;
            /** @example 0 */
            afterEventBuffer?: number;
            recurrence: components["schemas"]["Recurrence_2024_06_14"] | null;
            metadata: Record<string, never>;
            price: number;
            currency: string;
            lockTimeZoneToggleOnBookingPage: boolean;
            seatsPerTimeSlot?: number | null;
            forwardParamsSuccessRedirect: boolean | null;
            successRedirectUrl: string | null;
            isInstantEvent: boolean;
            seatsShowAvailabilityCount?: boolean | null;
            scheduleId: number | null;
            bookingLimitsCount?: Record<string, never>;
            onlyShowFirstAvailableSlot?: boolean;
            bookingLimitsDuration?: Record<string, never>;
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: (components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"])[];
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            confirmationPolicy?: Record<string, never>;
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            seats?: components["schemas"]["Seats_2024_06_14"];
            offsetStart?: number;
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"] | null;
            teamId: number;
            ownerId?: number | null;
            /** @description For managed event types, parent event type is the event type that this event type is based on */
            parentEventTypeId?: number | null;
            hosts: components["schemas"]["TeamEventTypeResponseHost"][];
            assignAllTeamMembers?: boolean;
            /** @enum {string} */
            schedulingType: "roundRobin" | "collective" | "managed";
            team: components["schemas"]["EventTypeTeam"];
        };
        GetTeamEventTypeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamEventTypeOutput_2024_06_14"];
        };
        CreatePhoneCallInput: {
            /** @description Your phone number */
            yourPhoneNumber: string;
            /** @description Number to call */
            numberToCall: string;
            /** @description CAL API Key */
            calApiKey: string;
            /**
             * @description Enabled status
             * @default true
             */
            enabled: Record<string, never>;
            /**
             * @description Template type
             * @default CUSTOM_TEMPLATE
             * @enum {string}
             */
            templateType: "CHECK_IN_APPOINTMENT" | "CUSTOM_TEMPLATE";
            /** @description Scheduler name */
            schedulerName?: string;
            /** @description Guest name */
            guestName?: string;
            /** @description Guest email */
            guestEmail?: string;
            /** @description Guest company */
            guestCompany?: string;
            /** @description Begin message */
            beginMessage?: string;
            /** @description General prompt */
            generalPrompt?: string;
        };
        Data: {
            callId: string;
            agentId?: string;
        };
        CreatePhoneCallOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Data"];
        };
        GetTeamEventTypesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamEventTypeOutput_2024_06_14"][];
        };
        UpdateTeamEventTypeInput_2024_06_14: {
            /** @example 60 */
            lengthInMinutes?: number;
            /**
             * @description If you want that user can choose between different lengths of the event you can specify them here. Must include the provided `lengthInMinutes`.
             * @example [
             *       15,
             *       30,
             *       60
             *     ]
             */
            lengthInMinutesOptions?: string[];
            /** @example Learn the secrets of masterchief! */
            title?: string;
            /** @example learn-the-secrets-of-masterchief */
            slug?: string;
            /** @example Discover the culinary wonders of the Argentina by making the best flan ever! */
            description?: string;
            /** @description Complete set of booking form fields. This array replaces all existing booking fields. To modify existing fields, first fetch the current event type, then include all desired fields in this array. Sending only one field will remove all other custom fields, keeping only default fields plus the provided one. */
            bookingFields?: (components["schemas"]["NameDefaultFieldInput_2024_06_14"] | components["schemas"]["EmailDefaultFieldInput_2024_06_14"] | components["schemas"]["TitleDefaultFieldInput_2024_06_14"] | components["schemas"]["LocationDefaultFieldInput_2024_06_14"] | components["schemas"]["NotesDefaultFieldInput_2024_06_14"] | components["schemas"]["GuestsDefaultFieldInput_2024_06_14"] | components["schemas"]["RescheduleReasonDefaultFieldInput_2024_06_14"] | components["schemas"]["PhoneFieldInput_2024_06_14"] | components["schemas"]["AddressFieldInput_2024_06_14"] | components["schemas"]["TextFieldInput_2024_06_14"] | components["schemas"]["NumberFieldInput_2024_06_14"] | components["schemas"]["TextAreaFieldInput_2024_06_14"] | components["schemas"]["SelectFieldInput_2024_06_14"] | components["schemas"]["MultiSelectFieldInput_2024_06_14"] | components["schemas"]["MultiEmailFieldInput_2024_06_14"] | components["schemas"]["CheckboxGroupFieldInput_2024_06_14"] | components["schemas"]["RadioGroupFieldInput_2024_06_14"] | components["schemas"]["BooleanFieldInput_2024_06_14"])[];
            /** @description If true, person booking this event can't add guests via their emails. */
            disableGuests?: boolean;
            /** @description Number representing length of each slot when event is booked. By default it equal length of the event type.
             *           If event length is 60 minutes then we would have slots 9AM, 10AM, 11AM etc. but if it was changed to 30 minutes then
             *           we would have slots 9AM, 9:30AM, 10AM, 10:30AM etc. as the available times to book the 60 minute event. */
            slotInterval?: number;
            /** @description Minimum number of minutes before the event that a booking can be made. */
            minimumBookingNotice?: number;
            /** @description Time spaces that can be prepended before an event to give more time before it. */
            beforeEventBuffer?: number;
            /** @description Time spaces that can be appended after an event to give more time after it. */
            afterEventBuffer?: number;
            /** @description If you want that this event has different schedule than user's default one you can specify it here. */
            scheduleId?: number;
            /** @description Limit how many times this event can be booked */
            bookingLimitsCount?: components["schemas"]["BaseBookingLimitsCount_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description This will limit your availability for this event type to one slot per day, scheduled at the earliest available time. */
            onlyShowFirstAvailableSlot?: boolean;
            /** @description Limit total amount of time that this event can be booked */
            bookingLimitsDuration?: components["schemas"]["BaseBookingLimitsDuration_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Limit how far in the future this event can be booked */
            bookingWindow?: components["schemas"]["BusinessDaysWindow_2024_06_14"] | components["schemas"]["CalendarDaysWindow_2024_06_14"] | components["schemas"]["RangeWindow_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Offset timeslots shown to bookers by a specified number of minutes */
            offsetStart?: number;
            /** @description Should booker have week, month or column view. Specify default layout and enabled layouts user can pick. */
            bookerLayouts?: components["schemas"]["BookerLayouts_2024_06_14"];
            /** @description Specify how the booking needs to be manually confirmed before it is pushed to the integrations and a confirmation mail is sent. */
            confirmationPolicy?: components["schemas"]["BaseConfirmationPolicy_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /** @description Create a recurring event type. */
            recurrence?: components["schemas"]["Recurrence_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            requiresBookerEmailVerification?: boolean;
            hideCalendarNotes?: boolean;
            lockTimeZoneToggleOnBookingPage?: boolean;
            color?: components["schemas"]["EventTypeColor_2024_06_14"];
            /** @description Create an event type with multiple seats. */
            seats?: components["schemas"]["Seats_2024_06_14"] | components["schemas"]["Disabled_2024_06_14"];
            /**
             * @description Customizable event name with valid variables:
             *           {Event type title}, {Organiser}, {Scheduler}, {Location}, {Organiser first name},
             *           {Scheduler first name}, {Scheduler last name}, {Event duration}, {LOCATION},
             *           {HOST/ATTENDEE}, {HOST}, {ATTENDEE}, {USER}
             * @example {Event type title} between {Organiser} and {Scheduler}
             */
            customName?: string;
            destinationCalendar?: components["schemas"]["DestinationCalendar_2024_06_14"];
            useDestinationCalendarEmail?: boolean;
            hideCalendarEventDetails?: boolean;
            /**
             * @description A valid URL where the booker will redirect to, once the booking is completed successfully
             * @example https://masterchief.com/argentina/flan/video/9129412
             */
            successRedirectUrl?: string;
            /** @description Boolean to Hide organizer's email address from the booking screen, email notifications, and calendar events */
            hideOrganizerEmail?: boolean;
            /** @description Cal video settings for the event type */
            calVideoSettings?: components["schemas"]["CalVideoSettings"];
            hosts?: components["schemas"]["Host"][];
            /** @description If true, all current and future team members will be assigned to this event type */
            assignAllTeamMembers?: boolean;
            /** @description Locations where the event will take place. If not provided, cal video link will be used as the location. */
            locations?: (components["schemas"]["InputAddressLocation_2024_06_14"] | components["schemas"]["InputLinkLocation_2024_06_14"] | components["schemas"]["InputIntegrationLocation_2024_06_14"] | components["schemas"]["InputPhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeAddressLocation_2024_06_14"] | components["schemas"]["InputAttendeePhoneLocation_2024_06_14"] | components["schemas"]["InputAttendeeDefinedLocation_2024_06_14"] | components["schemas"]["InputOrganizersDefaultApp_2024_06_14"])[];
        };
        UpdateTeamEventTypeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamEventTypeOutput_2024_06_14"] | components["schemas"]["TeamEventTypeOutput_2024_06_14"][];
        };
        DeleteTeamEventTypeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: Record<string, never>;
        };
        TeamMembershipOutput: {
            id: number;
            userId: number;
            teamId: number;
            accepted: boolean;
            /** @enum {string} */
            role: "MEMBER" | "OWNER" | "ADMIN";
            disableImpersonation?: boolean;
            user: components["schemas"]["MembershipUserOutputDto"];
        };
        OrgTeamMembershipsOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"][];
        };
        OrgTeamMembershipOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        UpdateOrgTeamMembershipDto: {
            accepted?: boolean;
            /** @enum {string} */
            role?: "MEMBER" | "OWNER" | "ADMIN";
            disableImpersonation?: boolean;
        };
        CreateOrgTeamMembershipDto: {
            userId: number;
            /** @default false */
            accepted: boolean;
            /**
             * @default MEMBER
             * @enum {string}
             */
            role: "MEMBER" | "OWNER" | "ADMIN";
            /** @default false */
            disableImpersonation: boolean;
        };
        Attribute: {
            /**
             * @description The ID of the attribute
             * @example attr_123
             */
            id: string;
            /**
             * @description The team ID associated with the attribute
             * @example 1
             */
            teamId: number;
            /**
             * @description The type of the attribute
             * @enum {string}
             */
            type: "TEXT" | "NUMBER" | "SINGLE_SELECT" | "MULTI_SELECT";
            /**
             * @description The name of the attribute
             * @example Attribute Name
             */
            name: string;
            /**
             * @description The slug of the attribute
             * @example attribute-name
             */
            slug: string;
            /**
             * @description Whether the attribute is enabled and displayed on their profile
             * @example true
             */
            enabled: boolean;
            /**
             * @description Whether users can edit the relation
             * @example true
             */
            usersCanEditRelation?: boolean;
        };
        GetOrganizationAttributesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Attribute"][];
        };
        GetSingleAttributeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Attribute"] | null;
        };
        CreateOrganizationAttributeOptionInput: {
            value: string;
            slug: string;
        };
        CreateOrganizationAttributeInput: {
            name: string;
            slug: string;
            /** @enum {string} */
            type: "TEXT" | "NUMBER" | "SINGLE_SELECT" | "MULTI_SELECT";
            options: components["schemas"]["CreateOrganizationAttributeOptionInput"][];
            enabled?: boolean;
        };
        CreateOrganizationAttributesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Attribute"];
        };
        UpdateOrganizationAttributeInput: {
            name?: string;
            slug?: string;
            /** @enum {string} */
            type?: "TEXT" | "NUMBER" | "SINGLE_SELECT" | "MULTI_SELECT";
            enabled?: boolean;
        };
        UpdateOrganizationAttributesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Attribute"];
        };
        DeleteOrganizationAttributesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["Attribute"];
        };
        OptionOutput: {
            /**
             * @description The ID of the option
             * @example attr_option_id
             */
            id: string;
            /**
             * @description The ID of the attribute
             * @example attr_id
             */
            attributeId: string;
            /**
             * @description The value of the option
             * @example option_value
             */
            value: string;
            /**
             * @description The slug of the option
             * @example option-slug
             */
            slug: string;
        };
        CreateAttributeOptionOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OptionOutput"];
        };
        DeleteAttributeOptionOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OptionOutput"];
        };
        UpdateOrganizationAttributeOptionInput: {
            value?: string;
            slug?: string;
        };
        UpdateAttributeOptionOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OptionOutput"];
        };
        GetAllAttributeOptionOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OptionOutput"][];
        };
        AssignedOptionOutput: {
            /**
             * @description The ID of the option
             * @example attr_option_id
             */
            id: string;
            /**
             * @description The ID of the attribute
             * @example attr_id
             */
            attributeId: string;
            /**
             * @description The value of the option
             * @example option_value
             */
            value: string;
            /**
             * @description The slug of the option
             * @example option-slug
             */
            slug: string;
            /**
             * @description Ids of the users assigned to the attribute option.
             * @example [
             *       124,
             *       224
             *     ]
             */
            assignedUserIds: string[];
        };
        GetAllAttributeAssignedOptionOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["AssignedOptionOutput"][];
        };
        AssignOrganizationAttributeOptionToUserInput: {
            value?: string;
            attributeOptionId?: string;
            attributeId: string;
        };
        AssignOptionUserOutputData: {
            /** @description The ID of the option assigned to the user */
            id: string;
            /** @description The ID form the org membership for the user */
            memberId: number;
            /** @description The value of the option */
            attributeOptionId: string;
        };
        AssignOptionUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["AssignOptionUserOutputData"];
        };
        UnassignOptionUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["AssignOptionUserOutputData"];
        };
        GetOptionUserOutputData: {
            /** @description The ID of the option assigned to the user */
            id: string;
            /** @description The ID of the attribute */
            attributeId: string;
            /** @description The value of the option */
            value: string;
            /** @description The slug of the option */
            slug: string;
        };
        GetOptionUserOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["GetOptionUserOutputData"][];
        };
        TeamWebhookOutputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate: string;
            teamId: number;
            id: number;
            triggers: Record<string, never>[];
            subscriberUrl: string;
            active: boolean;
            secret?: string;
        };
        TeamWebhooksOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamWebhookOutputDto"][];
        };
        CreateWebhookInputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate?: string;
            active: boolean;
            subscriberUrl: string;
            /**
             * @example [
             *       "BOOKING_CREATED",
             *       "BOOKING_RESCHEDULED",
             *       "BOOKING_CANCELLED",
             *       "BOOKING_CONFIRMED",
             *       "BOOKING_REJECTED",
             *       "BOOKING_COMPLETED",
             *       "BOOKING_NO_SHOW",
             *       "BOOKING_REOPENED"
             *     ]
             * @enum {string}
             */
            triggers: "BOOKING_CREATED" | "BOOKING_PAYMENT_INITIATED" | "BOOKING_PAID" | "BOOKING_RESCHEDULED" | "BOOKING_REQUESTED" | "BOOKING_CANCELLED" | "BOOKING_REJECTED" | "BOOKING_NO_SHOW_UPDATED" | "FORM_SUBMITTED" | "MEETING_ENDED" | "MEETING_STARTED" | "RECORDING_READY" | "INSTANT_MEETING" | "RECORDING_TRANSCRIPTION_GENERATED" | "OOO_CREATED" | "AFTER_HOSTS_CAL_VIDEO_NO_SHOW" | "AFTER_GUESTS_CAL_VIDEO_NO_SHOW" | "FORM_SUBMITTED_NO_EVENT";
            secret?: string;
        };
        TeamWebhookOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamWebhookOutputDto"];
        };
        UpdateWebhookInputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate?: string;
            active?: boolean;
            subscriberUrl?: string;
            /**
             * @example [
             *       "BOOKING_CREATED",
             *       "BOOKING_RESCHEDULED",
             *       "BOOKING_CANCELLED",
             *       "BOOKING_CONFIRMED",
             *       "BOOKING_REJECTED",
             *       "BOOKING_COMPLETED",
             *       "BOOKING_NO_SHOW",
             *       "BOOKING_REOPENED"
             *     ]
             * @enum {string}
             */
            triggers?: "BOOKING_CREATED" | "BOOKING_PAYMENT_INITIATED" | "BOOKING_PAID" | "BOOKING_RESCHEDULED" | "BOOKING_REQUESTED" | "BOOKING_CANCELLED" | "BOOKING_REJECTED" | "BOOKING_NO_SHOW_UPDATED" | "FORM_SUBMITTED" | "MEETING_ENDED" | "MEETING_STARTED" | "RECORDING_READY" | "INSTANT_MEETING" | "RECORDING_TRANSCRIPTION_GENERATED" | "OOO_CREATED" | "AFTER_HOSTS_CAL_VIDEO_NO_SHOW" | "AFTER_GUESTS_CAL_VIDEO_NO_SHOW" | "FORM_SUBMITTED_NO_EVENT";
            secret?: string;
        };
        CreateOutOfOfficeEntryDto: {
            /**
             * Format: date-time
             * @description The start date and time of the out of office period in ISO 8601 format in UTC timezone.
             * @example 2023-05-01T00:00:00.000Z
             */
            start: string;
            /**
             * Format: date-time
             * @description The end date and time of the out of office period in ISO 8601 format in UTC timezone.
             * @example 2023-05-10T23:59:59.999Z
             */
            end: string;
            /**
             * @description Optional notes for the out of office entry.
             * @example Vacation in Hawaii
             */
            notes?: string;
            /**
             * @description The ID of the user covering for the out of office period, if applicable.
             * @example 2
             */
            toUserId?: number;
            /**
             * @description the reason for the out of office entry, if applicable
             * @example vacation
             * @enum {string}
             */
            reason?: "unspecified" | "vacation" | "travel" | "sick" | "public_holiday";
        };
        UpdateOutOfOfficeEntryDto: {
            /**
             * Format: date-time
             * @description The start date and time of the out of office period in ISO 8601 format in UTC timezone.
             * @example 2023-05-01T00:00:00.000Z
             */
            start?: string;
            /**
             * Format: date-time
             * @description The end date and time of the out of office period in ISO 8601 format in UTC timezone.
             * @example 2023-05-10T23:59:59.999Z
             */
            end?: string;
            /**
             * @description Optional notes for the out of office entry.
             * @example Vacation in Hawaii
             */
            notes?: string;
            /**
             * @description The ID of the user covering for the out of office period, if applicable.
             * @example 2
             */
            toUserId?: number;
            /**
             * @description the reason for the out of office entry, if applicable
             * @example vacation
             * @enum {string}
             */
            reason?: "unspecified" | "vacation" | "travel" | "sick" | "public_holiday";
        };
        WorkflowActivationOutputDto: {
            /**
             * @description Whether the workflow is active for all event types associated with the team/user
             * @default false
             * @example false
             */
            isActiveOnAllEventTypes: boolean;
            /**
             * @description List of Event Type IDs the workflow is specifically active on (if not active on all)
             * @example [
             *       698191,
             *       698192
             *     ]
             */
            activeOnEventTypeIds?: number[];
        };
        WorkflowTriggerOffsetOutputDto: {
            /**
             * @description Time value for offset
             * @example 24
             */
            value: number;
            /**
             * @description Unit for the offset time
             * @example hour
             * @enum {string}
             */
            unit: "hour" | "minute" | "day";
        };
        WorkflowTriggerOutputDto: {
            /**
             * @description Trigger type for the workflow
             * @example beforeEvent
             * @enum {string}
             */
            type: "beforeEvent" | "eventCancelled" | "newEvent" | "afterEvent" | "rescheduleEvent" | "afterHostsCalVideoNoShow" | "afterGuestsCalVideoNoShow";
            /** @description Offset details (present for BEFORE_EVENT/AFTER_EVENT) */
            offset?: components["schemas"]["WorkflowTriggerOffsetOutputDto"];
        };
        WorkflowMessageOutputDto: {
            /**
             * @description Subject of the message
             * @example Reminder: Your Meeting {EVENT_NAME} - {EVENT_DATE_ddd, MMM D, YYYY h:mma} with Cal.com
             */
            subject: string;
            /**
             * @description HTML content of the message
             * @example <p>Reminder for {EVENT_NAME}.</p>
             */
            html?: string;
            /**
             * @description Text content of the message (used for SMS/WhatsApp)
             * @example Reminder for {EVENT_NAME}.
             */
            text?: string;
        };
        WorkflowStepOutputDto: {
            /**
             * @description Unique identifier of the step
             * @example 67244
             */
            id: number;
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Action to perform
             * @example email_host
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Intended recipient type
             * @example const
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Verified Email  if action is EMAIL_ADDRESS
             * @example 31214
             */
            email?: string;
            /** @description Verified Phone if action is SMS_NUMBER or WHATSAPP_NUMBER */
            phone?: string;
            /**
             * @description Template type used
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /**
             * @description Whether a calendar event (.ics) was included (for email actions)
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /**
             * @description Displayed sender name used for this step
             * @example Cal.com Notifications
             */
            sender: string;
            /** @description Message content for this step */
            message: components["schemas"]["WorkflowMessageOutputDto"];
        };
        WorkflowOutput: {
            /**
             * @description Unique identifier of the workflow
             * @example 101
             */
            id: number;
            /**
             * @description Name of the workflow
             * @example Platform Test Workflow
             */
            name: string;
            /**
             * @description ID of the user who owns the workflow (if not team-owned)
             * @example 2313
             */
            userId?: number;
            /**
             * @description ID of the team owning the workflow
             * @example 4214321
             */
            teamId?: number;
            /** @description Activation settings (scope) */
            activation: components["schemas"]["WorkflowActivationOutputDto"];
            /** @description Trigger configuration */
            trigger: components["schemas"]["WorkflowTriggerOutputDto"];
            /** @description Steps comprising the workflow */
            steps: components["schemas"]["WorkflowStepOutputDto"][];
            /**
             * @description Timestamp of creation
             * @example 2024-05-12T10:00:00.000Z
             */
            createdAt?: Record<string, never>;
            /**
             * @description Timestamp of last update
             * @example 2024-05-12T11:30:00.000Z
             */
            updatedAt?: Record<string, never>;
        };
        GetWorkflowsOutput: {
            /**
             * @description Indicates the status of the response
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description List of workflows */
            data: components["schemas"]["WorkflowOutput"][];
        };
        GetWorkflowOutput: {
            /**
             * @description Indicates the status of the response
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description workflow */
            data: components["schemas"]["WorkflowOutput"][];
        };
        WorkflowTriggerOffsetDto: {
            /**
             * @description Time value for offset before/after event trigger
             * @example 24
             */
            value: number;
            /**
             * @description Unit for the offset time
             * @example hour
             */
            unit: Record<string, never>;
        };
        OnBeforeEventTriggerDto: {
            /** @description Offset before/after the trigger time; required for BEFORE_EVENT and AFTER_EVENT only */
            offset: components["schemas"]["WorkflowTriggerOffsetDto"];
            /**
             * @description Trigger type for the workflow
             * @default beforeEvent
             * @example beforeEvent
             */
            type: string;
        };
        OnAfterEventTriggerDto: {
            /** @description Offset before/after the trigger time; required for BEFORE_EVENT and AFTER_EVENT only */
            offset: components["schemas"]["WorkflowTriggerOffsetDto"];
            /**
             * @description Trigger type for the workflow
             * @default afterEvent
             * @example afterEvent
             */
            type: string;
        };
        OnCancelTriggerDto: {
            /**
             * @description Trigger type for the workflow
             * @default eventCancelled
             */
            type: string;
        };
        OnCreationTriggerDto: {
            /**
             * @description Trigger type for the workflow
             * @default newEvent
             */
            type: string;
        };
        OnRescheduleTriggerDto: {
            /**
             * @description Trigger type for the workflow
             * @default rescheduleEvent
             */
            type: string;
        };
        OnAfterCalVideoGuestsNoShowTriggerDto: {
            /** @description Offset before/after the trigger time; required for BEFORE_EVENT and AFTER_EVENT only */
            offset: components["schemas"]["WorkflowTriggerOffsetDto"];
            /**
             * @description Trigger type for the workflow
             * @default afterGuestsCalVideoNoShow
             * @example afterGuestsCalVideoNoShow
             */
            type: string;
        };
        OnAfterCalVideoHostsNoShowTriggerDto: {
            /** @description Offset before/after the trigger time; required for BEFORE_EVENT and AFTER_EVENT only */
            offset: components["schemas"]["WorkflowTriggerOffsetDto"];
            /**
             * @description Trigger type for the workflow
             * @default afterHostsCalVideoNoShow
             * @example afterHostsCalVideoNoShow
             */
            type: string;
        };
        HtmlWorkflowMessageDto: {
            /**
             * @description Subject of the message
             * @example Reminder: Your Meeting {EVENT_NAME} - {EVENT_DATE_ddd, MMM D, YYYY h:mma} with Cal.com
             */
            subject: string;
            /**
             * @description HTML content of the message (used for Emails)
             * @example <p>This is a reminder from {ORGANIZER} of {EVENT_NAME} to {ATTENDEE} starting here  {LOCATION} {MEETING_URL} at {START_TIME_h:mma} {TIMEZONE}.</p>
             */
            html: string;
        };
        WorkflowEmailAddressStepDto: {
            /**
             * @description Action to perform, send an email to a specific email address
             * @default email_address
             * @example email_address
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Email address if recipient is EMAIL, required for action EMAIL_ADDRESS
             * @example 31214
             */
            verifiedEmailId: number;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
        };
        WorkflowEmailAttendeeStepDto: {
            /**
             * @description Action to perform, send an email to the attendees of the event
             * @default email_attendee
             * @example email_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
        };
        WorkflowEmailHostStepDto: {
            /**
             * @description Action to perform, send an email to the host of the event
             * @default email_host
             * @example email_host
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
        };
        TextWorkflowMessageDto: {
            /**
             * @description Subject of the message
             * @example Reminder: Your Meeting {EVENT_NAME} - {EVENT_DATE_ddd, MMM D, YYYY h:mma} with Cal.com
             */
            subject: string;
            /**
             * @description Text content of the message (used for SMS)
             * @example This is a reminder message from {ORGANIZER} of {EVENT_NAME} to {ATTENDEE} starting here {LOCATION} {MEETING_URL} at {START_TIME_h:mma} {TIMEZONE}.
             */
            text: string;
        };
        WorkflowPhoneWhatsAppAttendeeStepDto: {
            /**
             * @description Action to perform
             * @default whatsapp_attendee
             * @example whatsapp_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /** @description Message content for this step, send a text message via whatsapp to the phone numbers of the attendees */
            message: components["schemas"]["TextWorkflowMessageDto"];
        };
        WorkflowPhoneWhatsAppNumberStepDto: {
            /**
             * @description Action to perform, send a text message via whatsapp to a specific phone number
             * @default whatsapp_number
             * @example whatsapp_number
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            verifiedPhoneId: number;
            /** @description Message content for this step */
            message: components["schemas"]["TextWorkflowMessageDto"];
        };
        WorkflowPhoneNumberStepDto: {
            /**
             * @description Action to perform, send a text message to a specific phone number
             * @default sms_number
             * @example sms_number
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            verifiedPhoneId: number;
            /** @description Message content for this step */
            message: components["schemas"]["TextWorkflowMessageDto"];
        };
        WorkflowPhoneAttendeeStepDto: {
            /**
             * @description Action to perform, send a text message to the phone numbers of the attendees
             * @default sms_attendee
             * @example sms_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            message: components["schemas"]["TextWorkflowMessageDto"];
        };
        BaseWorkflowTriggerDto: {
            /** @description Trigger type for the workflow */
            type: Record<string, never>;
        };
        WorkflowActivationDto: {
            /**
             * @description Whether the workflow is active for all the event-types
             * @default false
             * @example false
             */
            isActiveOnAllEventTypes: boolean;
            /**
             * @description List of event-types IDs the workflow applies to, required if isActiveOnAllEventTypes is false
             * @default []
             * @example [
             *       698191
             *     ]
             */
            activeOnEventTypeIds: number[];
        };
        CreateWorkflowDto: {
            /**
             * @description Name of the workflow
             * @example Platform Test Workflow
             */
            name: string;
            /** @description Activation settings for the workflow */
            activation: components["schemas"]["WorkflowActivationDto"];
            /** @description Trigger configuration for the workflow */
            trigger: components["schemas"]["OnBeforeEventTriggerDto"] | components["schemas"]["OnAfterEventTriggerDto"] | components["schemas"]["OnCancelTriggerDto"] | components["schemas"]["OnCreationTriggerDto"] | components["schemas"]["OnRescheduleTriggerDto"] | components["schemas"]["OnAfterCalVideoGuestsNoShowTriggerDto"] | components["schemas"]["OnAfterCalVideoHostsNoShowTriggerDto"];
            /** @description Steps to execute as part of the workflow */
            steps: (components["schemas"]["WorkflowEmailAddressStepDto"] | components["schemas"]["WorkflowEmailAttendeeStepDto"] | components["schemas"]["WorkflowEmailHostStepDto"] | components["schemas"]["WorkflowPhoneWhatsAppAttendeeStepDto"] | components["schemas"]["WorkflowPhoneWhatsAppNumberStepDto"] | components["schemas"]["WorkflowPhoneNumberStepDto"] | components["schemas"]["WorkflowPhoneAttendeeStepDto"])[];
        };
        UpdateEmailAddressWorkflowStepDto: {
            /**
             * @description Action to perform, send an email to a specific email address
             * @default email_address
             * @example email_address
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Email address if recipient is EMAIL, required for action EMAIL_ADDRESS
             * @example 31214
             */
            verifiedEmailId: number;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdateEmailAttendeeWorkflowStepDto: {
            /**
             * @description Action to perform, send an email to the attendees of the event
             * @default email_attendee
             * @example email_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdateEmailHostWorkflowStepDto: {
            /**
             * @description Action to perform, send an email to the host of the event
             * @default email_host
             * @example email_host
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Whether to include a calendar event in the notification, can be included with actions email_host, email_attendee, email_address
             * @default false
             * @example true
             */
            includeCalendarEvent: Record<string, never>;
            /** @description Message content for this step */
            message: components["schemas"]["HtmlWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdatePhoneAttendeeWorkflowStepDto: {
            /**
             * @description Action to perform, send a text message to the phone numbers of the attendees
             * @default sms_attendee
             * @example sms_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            message: components["schemas"]["TextWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdatePhoneWhatsAppNumberWorkflowStepDto: {
            /**
             * @description Action to perform, send a text message via whatsapp to a specific phone number
             * @default whatsapp_number
             * @example whatsapp_number
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            verifiedPhoneId: number;
            /** @description Message content for this step */
            message: components["schemas"]["TextWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdateWhatsAppAttendeePhoneWorkflowStepDto: {
            /**
             * @description Action to perform
             * @default whatsapp_attendee
             * @example whatsapp_attendee
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /** @description Message content for this step, send a text message via whatsapp to the phone numbers of the attendees */
            message: components["schemas"]["TextWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdatePhoneNumberWorkflowStepDto: {
            /**
             * @description Action to perform, send a text message to a specific phone number
             * @default sms_number
             * @example sms_number
             * @enum {string}
             */
            action: "email_host" | "email_attendee" | "email_address" | "sms_attendee" | "sms_number" | "whatsapp_attendee" | "whatsapp_number";
            /**
             * @description Step number in the workflow sequence
             * @example 1
             */
            stepNumber: number;
            /**
             * @description Recipient type
             * @example attendee
             * @enum {string}
             */
            recipient: "const" | "attendee" | "email" | "phone_number";
            /**
             * @description Template type for the step
             * @example reminder
             * @enum {string}
             */
            template: "reminder" | "custom" | "rescheduled" | "completed" | "rating" | "cancelled";
            /** @description Displayed sender name. */
            sender: string;
            /**
             * @description Phone number if recipient is PHONE_NUMBER, required for actions SMS_NUMBER and WHATSAPP_NUMBER
             * @example 3243434
             */
            verifiedPhoneId: number;
            /** @description Message content for this step */
            message: components["schemas"]["TextWorkflowMessageDto"];
            /**
             * @description Unique identifier of the step you want to update, if adding a new step do not provide this id
             * @example 67244
             */
            id?: number;
        };
        UpdateWorkflowDto: {
            /**
             * @description Name of the workflow
             * @example Platform Test Workflow
             */
            name?: string;
            /** @description Activation settings for the workflow, the action that will trigger the workflow. */
            activation?: components["schemas"]["WorkflowActivationDto"];
            /** @description Trigger configuration for the workflow */
            trigger?: components["schemas"]["OnBeforeEventTriggerDto"] | components["schemas"]["OnAfterEventTriggerDto"] | components["schemas"]["OnCancelTriggerDto"] | components["schemas"]["OnCreationTriggerDto"] | components["schemas"]["OnRescheduleTriggerDto"] | components["schemas"]["OnAfterCalVideoGuestsNoShowTriggerDto"] | components["schemas"]["OnAfterCalVideoHostsNoShowTriggerDto"];
            /** @description Steps to execute as part of the workflow */
            steps?: (components["schemas"]["UpdateEmailAddressWorkflowStepDto"] | components["schemas"]["UpdateEmailAttendeeWorkflowStepDto"] | components["schemas"]["UpdateEmailHostWorkflowStepDto"] | components["schemas"]["UpdatePhoneAttendeeWorkflowStepDto"] | components["schemas"]["UpdatePhoneWhatsAppNumberWorkflowStepDto"] | components["schemas"]["UpdateWhatsAppAttendeePhoneWorkflowStepDto"] | components["schemas"]["UpdatePhoneNumberWorkflowStepDto"])[];
        };
        StripConnectOutputDto: {
            authUrl: string;
        };
        StripConnectOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["StripConnectOutputDto"];
        };
        StripCredentialsSaveOutputResponseDto: {
            url: string;
        };
        StripCredentialsCheckOutputResponseDto: {
            /** @example success */
            status: Record<string, never>;
        };
        GetDefaultScheduleOutput_2024_06_11: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput_2024_06_11"];
        };
        CreateTeamInput: {
            /**
             * @description Name of the team
             * @example CalTeam
             */
            name: string;
            /**
             * @description Team slug in kebab-case - if not provided will be generated automatically based on name.
             * @example caltel
             */
            slug?: string;
            /**
             * @description URL of the teams logo image
             * @example https://i.cal.com/api/avatar/b0b58752-68ad-4c0d-8024-4fa382a77752.png
             */
            logoUrl?: string;
            calVideoLogo?: string;
            appLogo?: string;
            appIconLogo?: string;
            bio?: string;
            /** @default false */
            hideBranding: boolean;
            isPrivate?: boolean;
            hideBookATeamMember?: boolean;
            /**
             * @description You can store any additional data you want here.
             *     Metadata must have at most 50 keys, each key up to 40 characters.
             *     Values can be strings (up to 500 characters), numbers, or booleans.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            theme?: string;
            brandColor?: string;
            darkBrandColor?: string;
            /**
             * @description URL of the teams banner image which is shown on booker
             * @example https://i.cal.com/api/avatar/949be534-7a88-4185-967c-c020b0c0bef3.png
             */
            bannerUrl?: string;
            timeFormat?: number;
            /**
             * @description Timezone is used to create teams's default schedule from Monday to Friday from 9AM to 5PM. It will default to Europe/London if not passed.
             * @default Europe/London
             * @example America/New_York
             */
            timeZone: string;
            /**
             * @default Sunday
             * @example Monday
             */
            weekStart: string;
            /**
             * @description If you are a platform customer, don't pass 'false', because then team creator won't be able to create team event types.
             * @default true
             */
            autoAcceptCreator: boolean;
        };
        CreateTeamOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Either an Output object or a TeamOutputDto. */
            data: components["schemas"]["TeamOutputDto"];
        };
        TeamOutputDto: {
            id: number;
            parentId?: number;
            name: string;
            slug?: string;
            logoUrl?: string;
            calVideoLogo?: string;
            appLogo?: string;
            appIconLogo?: string;
            bio?: string;
            hideBranding?: boolean;
            isOrganization: boolean;
            isPrivate?: boolean;
            /** @default false */
            hideBookATeamMember: boolean;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            theme?: string;
            brandColor?: string;
            darkBrandColor?: string;
            bannerUrl?: string;
            timeFormat?: number;
            /** @default Europe/London */
            timeZone: string;
            /** @default Sunday */
            weekStart: string;
        };
        GetTeamOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamOutputDto"];
        };
        GetTeamsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamOutputDto"][];
        };
        UpdateTeamOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamOutputDto"];
        };
        ConferencingAppsOutputDto: {
            /** @description Id of the conferencing app credentials */
            id: number;
            /**
             * @description Type of conferencing app
             * @example google_video
             */
            type: string;
            /** @description Id of the user associated to the conferencing app */
            userId: number;
            /**
             * @description Whether if the connection is working or not.
             * @example true
             */
            invalid?: boolean | null;
        };
        ConferencingAppOutputResponseDto: {
            /** @enum {string} */
            status: "success" | "error";
            data: components["schemas"]["ConferencingAppsOutputDto"];
        };
        GetConferencingAppsOauthUrlResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        ConferencingAppsOutputResponseDto: {
            /** @enum {string} */
            status: "success" | "error";
            data: components["schemas"]["ConferencingAppsOutputDto"][];
        };
        SetDefaultConferencingAppOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        DefaultConferencingAppsOutputDto: {
            appSlug?: string;
            appLink?: string;
        };
        GetDefaultConferencingAppOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data?: components["schemas"]["DefaultConferencingAppsOutputDto"];
        };
        DisconnectConferencingAppOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        GoogleServiceAccountKeyInput: {
            private_key: string;
            client_email: string;
            client_id: string;
        };
        CreateDelegationCredentialInput: {
            workspacePlatformSlug: string;
            domain: string;
            serviceAccountKey: components["schemas"]["GoogleServiceAccountKeyInput"][];
        };
        WorkspacePlatformDto: {
            name: string;
            slug: string;
        };
        DelegationCredentialOutput: {
            id: string;
            enabled: boolean;
            domain: string;
            organizationId: number;
            workspacePlatform: components["schemas"]["WorkspacePlatformDto"];
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
        };
        CreateDelegationCredentialOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["DelegationCredentialOutput"];
        };
        UpdateDelegationCredentialInput: {
            enabled?: boolean;
            serviceAccountKey?: components["schemas"]["GoogleServiceAccountKeyInput"][];
        };
        UpdateDelegationCredentialOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["DelegationCredentialOutput"];
        };
        CreateIcsFeedInputDto: {
            /**
             * @description An array of ICS URLs
             * @example [
             *       "https://cal.com/ics/feed.ics",
             *       "http://cal.com/ics/feed.ics"
             *     ]
             */
            urls: string[];
            /**
             * @description Whether to allowing writing to the calendar or not
             * @default true
             * @example false
             */
            readOnly: boolean;
        };
        CreateIcsFeedOutput: {
            /**
             * @description The id of the calendar credential
             * @example 1234567890
             */
            id: number;
            /**
             * @description The type of the calendar
             * @example ics-feed_calendar
             */
            type: string;
            /**
             * @description The user id of the user that created the calendar
             * @example 1234567890
             */
            userId: number | null;
            /**
             * @description The team id of the user that created the calendar
             * @example 1234567890
             */
            teamId: number | null;
            /**
             * @description The slug of the calendar
             * @example ics-feed
             */
            appId: string | null;
            /**
             * @description Whether the calendar credentials are valid or not
             * @example false
             */
            invalid: boolean | null;
        };
        CreateIcsFeedOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["CreateIcsFeedOutput"];
        };
        BusyTimesOutput: {
            /** Format: date-time */
            start: string;
            /** Format: date-time */
            end: string;
            source?: string | null;
        };
        GetBusyTimesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["BusyTimesOutput"][];
        };
        Integration: {
            appData?: Record<string, never> | null;
            dirName?: string;
            __template?: string;
            name: string;
            description: string;
            installed?: boolean;
            type: string;
            title?: string;
            variant: string;
            category?: string;
            categories: string[];
            logo: string;
            publisher: string;
            slug: string;
            url: string;
            email: string;
            locationOption: Record<string, never> | null;
        };
        Primary: {
            externalId: string;
            integration?: string;
            name?: string;
            primary: boolean | null;
            readOnly: boolean;
            email?: string;
            isSelected: boolean;
            credentialId: number;
            delegationCredentialId?: string | null;
        };
        Calendar: {
            externalId: string;
            integration?: string;
            name?: string;
            primary?: boolean | null;
            readOnly: boolean;
            email?: string;
            isSelected: boolean;
            credentialId: number;
            delegationCredentialId?: string | null;
        };
        ConnectedCalendar: {
            integration: components["schemas"]["Integration"];
            credentialId: number;
            delegationCredentialId?: string | null;
            primary?: components["schemas"]["Primary"];
            calendars?: components["schemas"]["Calendar"][];
        };
        DestinationCalendar: {
            id: Record<string, never>;
            integration: string;
            externalId: string;
            primaryEmail: string | null;
            userId: number | null;
            eventTypeId: number | null;
            credentialId: number | null;
            delegationCredentialId?: string | null;
            name?: string | null;
            primary?: boolean;
            readOnly?: boolean;
            email?: string;
            integrationTitle?: string;
        };
        ConnectedCalendarsData: {
            connectedCalendars: components["schemas"]["ConnectedCalendar"][];
            destinationCalendar: components["schemas"]["DestinationCalendar"];
        };
        ConnectedCalendarsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ConnectedCalendarsData"];
        };
        CreateCalendarCredentialsInput: {
            username: string;
            password: string;
        };
        DeleteCalendarCredentialsInputBodyDto: {
            /**
             * @description Credential ID of the calendar to delete, as returned by the /calendars endpoint
             * @example 10
             */
            id: number;
        };
        DeletedCalendarCredentialsOutputDto: {
            id: number;
            type: string;
            userId: number | null;
            teamId: number | null;
            appId: string | null;
            invalid: boolean | null;
        };
        DeletedCalendarCredentialsOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["DeletedCalendarCredentialsOutputDto"];
        };
        CreateOrganizationInput: {
            /**
             * @description For how many days is managed organization api key valid. Defaults to 30 days.
             * @default 30
             * @example 60
             */
            apiKeyDaysValid: number;
            /**
             * @description If true, organization api key never expires.
             * @example true
             */
            apiKeyNeverExpires?: boolean;
            /**
             * @description Name of the organization
             * @example CalTeam
             */
            name: string;
            /**
             * @description Organization slug in kebab-case - if not provided will be generated automatically based on name.
             * @example cal-tel
             */
            slug?: string;
            /**
             * @description You can store any additional data you want here.
             *     Metadata must have at most 50 keys, each key up to 40 characters.
             *     Values can be strings (up to 500 characters), numbers, or booleans.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
        };
        ManagedOrganizationWithApiKeyOutput: {
            id: number;
            name: string;
            slug?: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            apiKey: string;
        };
        CreateManagedOrganizationOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ManagedOrganizationWithApiKeyOutput"];
        };
        ManagedOrganizationOutput: {
            id: number;
            name: string;
            slug?: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
        };
        GetManagedOrganizationOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ManagedOrganizationOutput"];
        };
        PaginationMetaDto: {
            /**
             * @description The total number of items available across all pages, matching the query criteria.
             * @example 123
             */
            totalItems: number;
            /**
             * @description The number of items remaining to be fetched *after* the current page. Calculated as: `totalItems - (skip + itemsPerPage)`.
             * @example 103
             */
            remainingItems: number;
            /**
             * @description The number of items returned in the current page.
             * @example 10
             */
            returnedItems: number;
            /**
             * @description The maximum number of items requested per page.
             * @example 10
             */
            itemsPerPage: number;
            /**
             * @description The current page number being returned.
             * @example 2
             */
            currentPage: number;
            /**
             * @description The total number of pages available.
             * @example 13
             */
            totalPages: number;
            /**
             * @description Indicates if there is a subsequent page available after the current one.
             * @example true
             */
            hasNextPage: boolean;
            /**
             * @description Indicates if there is a preceding page available before the current one.
             * @example true
             */
            hasPreviousPage: boolean;
        };
        GetManagedOrganizationsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ManagedOrganizationOutput"][];
            pagination: components["schemas"]["PaginationMetaDto"];
        };
        UpdateOrganizationInput: {
            /**
             * @description Name of the organization
             * @example CalTeam
             */
            name?: string;
            /**
             * @description You can store any additional data you want here.
             *     Metadata must have at most 50 keys, each key up to 40 characters.
             *     Values can be strings (up to 500 characters), numbers, or booleans.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
        };
        RoutingFormResponseOutput: {
            id: number;
            formId: string;
            formFillerId: string;
            routedToBookingUid: string;
            /** @example {
             *       "f00b26df-f54b-4985-8d98-17c5482c6a24": {
             *         "label": "participant",
             *         "value": "mamut"
             *       }
             *     } */
            response: Record<string, never>;
            /** Format: date-time */
            createdAt: string;
        };
        GetRoutingFormResponsesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["RoutingFormResponseOutput"];
        };
        Routing: {
            /**
             * @description The ID of the queued form response. Only present if the form response was queued.
             * @example 123
             */
            queuedResponseId?: string | null;
            /**
             * @description The ID of the routing form response.
             * @example 123
             */
            responseId?: number | null;
            /**
             * @description Array of team member IDs that were routed to handle this booking.
             * @example [
             *       101,
             *       102
             *     ]
             */
            teamMemberIds: number[];
            /**
             * @description The email of the team member assigned to handle this booking.
             * @example john.doe@example.com
             */
            teamMemberEmail?: string;
            /**
             * @description Whether to skip contact owner assignment from CRM integration.
             * @example true
             */
            skipContactOwner?: boolean;
            /**
             * @description The CRM application slug for integration.
             * @example salesforce
             */
            crmAppSlug?: string;
            /**
             * @description The CRM owner record type for contact assignment.
             * @example Account
             */
            crmOwnerRecordType?: string;
        };
        CreateRoutingFormResponseOutputData: {
            /**
             * @description The ID of the event type that was routed to.
             * @example 123
             */
            eventTypeId?: number;
            /**
             * @description The routing information that could be passed as is to the booking API.
             * @example {
             *       "eventTypeId": 123,
             *       "routing": {
             *         "teamMemberIds": [
             *           101,
             *           102
             *         ],
             *         "teamMemberEmail": "john.doe@example.com",
             *         "skipContactOwner": true
             *       }
             *     }
             */
            routing?: components["schemas"]["Routing"];
            /**
             * @description A custom message to be displayed to the user in case of routing to a custom page.
             * @example This is a custom message.
             */
            routingCustomMessage?: string;
            /**
             * @description The external redirect URL to be used in case of routing to a non cal.com event type URL.
             * @example https://example.com/
             */
            routingExternalRedirectUrl?: string;
            slots?: components["schemas"]["SlotsOutput_2024_09_04"] | components["schemas"]["RangeSlotsOutput_2024_09_04"];
        };
        CreateRoutingFormResponseOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["CreateRoutingFormResponseOutputData"];
        };
        UpdateRoutingFormResponseInput: {
            /** @description The updated response data */
            response?: Record<string, never>;
        };
        UpdateRoutingFormResponseOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["RoutingFormResponseOutput"];
        };
        RoutingFormOutput: {
            /** @example My Form */
            name: string;
            /** @example This is the description. */
            description: string | null;
            /** @example 0 */
            position: number;
            /** @example 2024-03-28T10:00:00.000Z */
            createdAt: string;
            /** @example 2024-03-28T10:00:00.000Z */
            updatedAt: string;
            /** @example 2313 */
            userId: number;
            /** @example 4214321 */
            teamId: number | null;
            /** @example false */
            disabled: boolean;
            id: string;
            routes: Record<string, never> | null;
            fields: Record<string, never> | null;
            settings: Record<string, never> | null;
        };
        GetRoutingFormsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["RoutingFormOutput"][];
        };
        SlotsOutput_2024_09_04: Record<string, never>;
        RangeSlotsOutput_2024_09_04: Record<string, never>;
        ResponseSlotsOutputData: {
            eventTypeId: number;
            slots: components["schemas"]["SlotsOutput_2024_09_04"] | components["schemas"]["RangeSlotsOutput_2024_09_04"];
        };
        ResponseSlotsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ResponseSlotsOutputData"];
        };
        ReserveSlotInput_2024_09_04: {
            /**
             * @description The ID of the event type for which slot should be reserved.
             * @example 1
             */
            eventTypeId: number;
            /**
             * @description ISO 8601 datestring in UTC timezone representing available slot.
             * @example 2024-09-04T09:00:00Z
             */
            slotStart: string;
            /**
             * @description By default slot duration is equal to event type length, but if you want to reserve a slot for an event type that has a variable length you can specify it here as a number in minutes. If you don't have this set explicitly that event type can have one of many lengths you can omit this.
             * @example 30
             */
            slotDuration?: number;
            /**
             * @description ONLY for authenticated requests with api key, access token or OAuth credentials (ID + secret).
             *
             *           For how many minutes the slot should be reserved - for this long time noone else can book this event type at `start` time. If not provided, defaults to 5 minutes.
             * @example 5
             */
            reservationDuration?: number;
        };
        ReserveSlotOutput_2024_09_04: {
            /**
             * @description The ID of the event type for which slot was reserved.
             * @example 1
             */
            eventTypeId: number;
            /**
             * @description ISO 8601 datestring in UTC timezone representing available slot.
             * @example 2024-09-04T09:00:00Z
             */
            slotStart: string;
            /**
             * @description ISO 8601 datestring in UTC timezone representing slot end.
             * @example 2024-09-04T10:00:00Z
             */
            slotEnd: string;
            /**
             * @description By default slot duration is equal to event type length, but if you want to reserve a slot for an event type that has a variable length you can specify it here. If you don't have this set explicitly that event type can have one of many lengths you can omit this.
             * @example 30
             */
            slotDuration: number;
            /**
             * @description The unique identifier of the reservation. Use it to update, get or delete the reservation.
             * @example e84be5a3-4696-49e3-acc7-b2f3999c3b94
             */
            reservationUid: string;
            /**
             * @description For how many minutes the slot is reserved - for this long time noone else can book this event type at `start` time.
             * @example 5
             */
            reservationDuration: number;
            /**
             * @description ISO 8601 datestring in UTC timezone representing time until which the slot is reserved.
             * @example 2023-09-04T10:00:00Z
             */
            reservationUntil: string;
        };
        ReserveSlotOutputResponse_2024_09_04: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ReserveSlotOutput_2024_09_04"];
        };
        GetReservedSlotOutput_2024_09_04: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["GetReservedSlotOutput_2024_09_04"] | null;
        };
        MeOrgOutput: {
            isPlatform: boolean;
            id: number;
        };
        MeOutput: {
            id: number;
            username: string;
            email: string;
            timeFormat: number;
            defaultScheduleId: number | null;
            weekStart: string;
            timeZone: string;
            organizationId: number | null;
            organization?: components["schemas"]["MeOrgOutput"];
        };
        GetMeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["MeOutput"];
        };
        UpdateMeOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["MeOutput"];
        };
        BookingInputAddressLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `address` - it refers to address defined by the organizer.
             * @example address
             */
            type: string;
        };
        BookingInputAttendeeAddressLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `attendeeAddress`
             * @example attendeeAddress
             */
            type: string;
            /** @example 123 Example St, City, Country */
            address: string;
        };
        BookingInputAttendeeDefinedLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `attendeeDefined`
             * @example attendeeDefined
             */
            type: string;
            /** @example 321 Example St, City, Country */
            location: string;
        };
        BookingInputAttendeePhoneLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `attendeePhone`
             * @example attendeePhone
             */
            type: string;
            /** @example +37120993151 */
            phone: string;
        };
        BookingInputIntegrationLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `integration`
             * @example integration
             */
            type: string;
            /**
             * @example cal-video
             * @enum {string}
             */
            integration: "cal-video" | "google-meet" | "zoom" | "whereby-video" | "whatsapp-video" | "webex-video" | "telegram-video" | "tandem" | "sylaps-video" | "skype-video" | "sirius-video" | "signal-video" | "shimmer-video" | "salesroom-video" | "roam-video" | "riverside-video" | "ping-video" | "office365-video" | "mirotalk-video" | "jitsi" | "jelly-video" | "jelly-conferencing" | "huddle" | "facetime-video" | "element-call-video" | "eightxeight-video" | "discord-video" | "demodesk-video" | "campfire-video";
        };
        BookingInputLinkLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `link` - it refers to link defined by the organizer.
             * @example link
             */
            type: string;
        };
        BookingInputPhoneLocation_2024_08_13: {
            /**
             * @description only allowed value for type is `phone` - it refers to phone defined by the organizer.
             * @example phone
             */
            type: string;
        };
        BookingInputOrganizersDefaultAppLocation_2024_08_13: {
            /**
             * @description only available for team event types and the only allowed value for type is `organizersDefaultApp` - it refers to the default app defined by the organizer.
             * @example organizersDefaultApp
             */
            type: string;
        };
        ValidateBookingLocation_2024_08_13: Record<string, never>;
        CreateBookingAttendee: {
            /**
             * @description The name of the attendee.
             * @example John Doe
             */
            name: string;
            /**
             * @description The email of the attendee.
             * @example john.doe@example.com
             */
            email?: string;
            /**
             * @description The time zone of the attendee.
             * @example America/New_York
             */
            timeZone: string;
            /**
             * @description The phone number of the attendee in international format.
             * @example +919876543210
             */
            phoneNumber?: string;
            /**
             * @description The preferred language of the attendee. Used for booking confirmation.
             * @default en
             * @example it
             * @enum {string}
             */
            language: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
        };
        CreateBookingInput_2024_08_13: {
            /**
             * @description The start time of the booking in ISO 8601 format in UTC timezone.
             * @example 2024-08-13T09:00:00Z
             */
            start: string;
            /** @description The attendee's details. */
            attendee: components["schemas"]["CreateBookingAttendee"];
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values for custom booking fields added by you.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses?: Record<string, never>;
            /**
             * @description The ID of the event type that is booked. Required unless eventTypeSlug and username are provided as an alternative to identifying the event type.
             * @example 123
             */
            eventTypeId?: number;
            /**
             * @description The slug of the event type. Required along with username / teamSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example my-event-type
             */
            eventTypeSlug?: string;
            /**
             * @description The username of the event owner. Required along with eventTypeSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example john-doe
             */
            username?: string;
            /**
             * @description Team slug for team that owns event type for which slots are fetched. Required along with eventTypeSlug and optionally organizationSlug if the team is part of organization
             * @example john-doe
             */
            teamSlug?: string;
            /**
             * @description The organization slug. Optional, only used when booking with eventTypeSlug + username or eventTypeSlug + teamSlug.
             * @example acme-corp
             */
            organizationSlug?: string;
            /**
             * @description An optional list of guest emails attending the event.
             * @example [
             *       "guest1@example.com",
             *       "guest2@example.com"
             *     ]
             */
            guests?: string[];
            /**
             * @deprecated
             * @description Deprecated - use 'location' instead. Meeting URL just for this booking. Displayed in email and calendar event. If not provided then cal video link will be generated.
             * @example https://example.com/meeting
             */
            meetingUrl?: string;
            /** @description One of the event type locations. If instead of passing one of the location objects as required by schema you are still passing a string please use an object. */
            location?: components["schemas"]["BookingInputAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeDefinedLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeePhoneLocation_2024_08_13"] | components["schemas"]["BookingInputIntegrationLocation_2024_08_13"] | components["schemas"]["BookingInputLinkLocation_2024_08_13"] | components["schemas"]["BookingInputPhoneLocation_2024_08_13"] | components["schemas"]["BookingInputOrganizersDefaultAppLocation_2024_08_13"];
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and string values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            /**
             * @description If it is an event type that has multiple possible lengths that attendee can pick from, you can pass the desired booking length here.
             *         If not provided then event type default length will be used for the booking.
             * @example 30
             */
            lengthInMinutes?: number;
            /**
             * @description Routing information from routing forms that determined the booking assignment. Both responseId and teamMemberIds are required if provided.
             * @example {
             *       "responseId": 123,
             *       "teamMemberIds": [
             *         101,
             *         102
             *       ]
             *     }
             */
            routing?: components["schemas"]["Routing"];
        };
        CreateInstantBookingInput_2024_08_13: {
            /**
             * @description The start time of the booking in ISO 8601 format in UTC timezone.
             * @example 2024-08-13T09:00:00Z
             */
            start: string;
            /** @description The attendee's details. */
            attendee: components["schemas"]["CreateBookingAttendee"];
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values for custom booking fields added by you.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses?: Record<string, never>;
            /**
             * @description The ID of the event type that is booked. Required unless eventTypeSlug and username are provided as an alternative to identifying the event type.
             * @example 123
             */
            eventTypeId?: number;
            /**
             * @description The slug of the event type. Required along with username / teamSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example my-event-type
             */
            eventTypeSlug?: string;
            /**
             * @description The username of the event owner. Required along with eventTypeSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example john-doe
             */
            username?: string;
            /**
             * @description Team slug for team that owns event type for which slots are fetched. Required along with eventTypeSlug and optionally organizationSlug if the team is part of organization
             * @example john-doe
             */
            teamSlug?: string;
            /**
             * @description The organization slug. Optional, only used when booking with eventTypeSlug + username or eventTypeSlug + teamSlug.
             * @example acme-corp
             */
            organizationSlug?: string;
            /**
             * @description An optional list of guest emails attending the event.
             * @example [
             *       "guest1@example.com",
             *       "guest2@example.com"
             *     ]
             */
            guests?: string[];
            /**
             * @deprecated
             * @description Deprecated - use 'location' instead. Meeting URL just for this booking. Displayed in email and calendar event. If not provided then cal video link will be generated.
             * @example https://example.com/meeting
             */
            meetingUrl?: string;
            /** @description One of the event type locations. If instead of passing one of the location objects as required by schema you are still passing a string please use an object. */
            location?: components["schemas"]["BookingInputAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeDefinedLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeePhoneLocation_2024_08_13"] | components["schemas"]["BookingInputIntegrationLocation_2024_08_13"] | components["schemas"]["BookingInputLinkLocation_2024_08_13"] | components["schemas"]["BookingInputPhoneLocation_2024_08_13"] | components["schemas"]["BookingInputOrganizersDefaultAppLocation_2024_08_13"];
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and string values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            /**
             * @description If it is an event type that has multiple possible lengths that attendee can pick from, you can pass the desired booking length here.
             *         If not provided then event type default length will be used for the booking.
             * @example 30
             */
            lengthInMinutes?: number;
            /**
             * @description Routing information from routing forms that determined the booking assignment. Both responseId and teamMemberIds are required if provided.
             * @example {
             *       "responseId": 123,
             *       "teamMemberIds": [
             *         101,
             *         102
             *       ]
             *     }
             */
            routing?: components["schemas"]["Routing"];
            /**
             * @description Flag indicating if the booking is an instant booking. Only available for team events.
             * @example true
             */
            instant: boolean;
        };
        CreateRecurringBookingInput_2024_08_13: {
            /**
             * @description The start time of the booking in ISO 8601 format in UTC timezone.
             * @example 2024-08-13T09:00:00Z
             */
            start: string;
            /** @description The attendee's details. */
            attendee: components["schemas"]["CreateBookingAttendee"];
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values for custom booking fields added by you.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses?: Record<string, never>;
            /**
             * @description The ID of the event type that is booked. Required unless eventTypeSlug and username are provided as an alternative to identifying the event type.
             * @example 123
             */
            eventTypeId?: number;
            /**
             * @description The slug of the event type. Required along with username / teamSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example my-event-type
             */
            eventTypeSlug?: string;
            /**
             * @description The username of the event owner. Required along with eventTypeSlug and optionally organizationSlug if eventTypeId is not provided.
             * @example john-doe
             */
            username?: string;
            /**
             * @description Team slug for team that owns event type for which slots are fetched. Required along with eventTypeSlug and optionally organizationSlug if the team is part of organization
             * @example john-doe
             */
            teamSlug?: string;
            /**
             * @description The organization slug. Optional, only used when booking with eventTypeSlug + username or eventTypeSlug + teamSlug.
             * @example acme-corp
             */
            organizationSlug?: string;
            /**
             * @description An optional list of guest emails attending the event.
             * @example [
             *       "guest1@example.com",
             *       "guest2@example.com"
             *     ]
             */
            guests?: string[];
            /**
             * @deprecated
             * @description Deprecated - use 'location' instead. Meeting URL just for this booking. Displayed in email and calendar event. If not provided then cal video link will be generated.
             * @example https://example.com/meeting
             */
            meetingUrl?: string;
            /** @description One of the event type locations. If instead of passing one of the location objects as required by schema you are still passing a string please use an object. */
            location?: components["schemas"]["BookingInputAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeAddressLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeeDefinedLocation_2024_08_13"] | components["schemas"]["BookingInputAttendeePhoneLocation_2024_08_13"] | components["schemas"]["BookingInputIntegrationLocation_2024_08_13"] | components["schemas"]["BookingInputLinkLocation_2024_08_13"] | components["schemas"]["BookingInputPhoneLocation_2024_08_13"] | components["schemas"]["BookingInputOrganizersDefaultAppLocation_2024_08_13"];
            /**
             * @description You can store any additional data you want here. Metadata must have at most 50 keys, each key up to 40 characters, and string values up to 500 characters.
             * @example {
             *       "key": "value"
             *     }
             */
            metadata?: Record<string, never>;
            /**
             * @description If it is an event type that has multiple possible lengths that attendee can pick from, you can pass the desired booking length here.
             *         If not provided then event type default length will be used for the booking.
             * @example 30
             */
            lengthInMinutes?: number;
            /**
             * @description Routing information from routing forms that determined the booking assignment. Both responseId and teamMemberIds are required if provided.
             * @example {
             *       "responseId": 123,
             *       "teamMemberIds": [
             *         101,
             *         102
             *       ]
             *     }
             */
            routing?: components["schemas"]["Routing"];
            /**
             * @description The number of recurrences. If not provided then event type recurrence count will be used. Can't be more than
             *         event type recurrence count
             * @example 5
             */
            recurrenceCount?: number;
        };
        BookingHost: {
            /** @example 1 */
            id: number;
            /** @example Jane Doe */
            name: string;
            /** @example jane100@example.com */
            email: string;
            /** @example jane100 */
            username: string;
            /** @example America/Los_Angeles */
            timeZone: string;
        };
        EventType: {
            /** @example 1 */
            id: number;
            /** @example some-event */
            slug: string;
        };
        BookingAttendee: {
            /** @example John Doe */
            name: string;
            /** @example john@example.com */
            email: string;
            /** @example America/New_York */
            timeZone: string;
            /**
             * @example en
             * @enum {string}
             */
            language?: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
            /** @example false */
            absent: boolean;
            /** @example +1234567890 */
            phoneNumber?: string;
        };
        BookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            attendees: components["schemas"]["BookingAttendee"][];
            /** @example [
             *       "guest1@example.com",
             *       "guest2@example.com"
             *     ] */
            guests?: string[];
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses: Record<string, never>;
        };
        RecurringBookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            attendees: components["schemas"]["BookingAttendee"][];
            /** @example [
             *       "guest1@example.com",
             *       "guest2@example.com"
             *     ] */
            guests?: string[];
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses: Record<string, never>;
            /** @example recurring_uid_987 */
            recurringBookingUid: string;
        };
        SeatedAttendee: {
            /** @example John Doe */
            name: string;
            /** @example john@example.com */
            email: string;
            /** @example America/New_York */
            timeZone: string;
            /**
             * @example en
             * @enum {string}
             */
            language?: "ar" | "ca" | "de" | "es" | "eu" | "he" | "id" | "ja" | "lv" | "pl" | "ro" | "sr" | "th" | "vi" | "az" | "cs" | "el" | "es-419" | "fi" | "hr" | "it" | "km" | "nl" | "pt" | "ru" | "sv" | "tr" | "zh-CN" | "bg" | "da" | "en" | "et" | "fr" | "hu" | "iw" | "ko" | "no" | "pt-BR" | "sk" | "ta" | "uk" | "zh-TW" | "bn";
            /** @example false */
            absent: boolean;
            /** @example +1234567890 */
            phoneNumber?: string;
            /** @example 3be561a9-31f1-4b8e-aefc-9d9a085f0dd1 */
            seatUid: string;
            /**
             * @description Booking field responses consisting of an object with booking field slug as keys and user response as values.
             * @example {
             *       "customField": "customValue"
             *     }
             */
            bookingFieldsResponses: Record<string, never>;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
        };
        CreateSeatedBookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            /** @example 3be561a9-31f1-4b8e-aefc-9d9a085f0dd1 */
            seatUid: string;
            attendees: components["schemas"]["SeatedAttendee"][];
        };
        CreateRecurringSeatedBookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            /** @example 3be561a9-31f1-4b8e-aefc-9d9a085f0dd1 */
            seatUid: string;
            attendees: components["schemas"]["SeatedAttendee"][];
            /** @example recurring_uid_987 */
            recurringBookingUid: string;
        };
        CreateBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a BookingOutput object or an array of RecurringBookingOutput objects */
            data: components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"][] | components["schemas"]["CreateSeatedBookingOutput_2024_08_13"] | components["schemas"]["CreateRecurringSeatedBookingOutput_2024_08_13"][];
        };
        GetSeatedBookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            attendees: components["schemas"]["SeatedAttendee"][];
        };
        GetRecurringSeatedBookingOutput_2024_08_13: {
            /** @example 123 */
            id: number;
            /** @example booking_uid_123 */
            uid: string;
            /** @example Consultation */
            title: string;
            /** @example Learn how to integrate scheduling into marketplace. */
            description: string;
            hosts: components["schemas"]["BookingHost"][];
            /**
             * @example accepted
             * @enum {string}
             */
            status: "cancelled" | "accepted" | "rejected" | "pending";
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @example canceller@example.com */
            cancelledByEmail?: string;
            /** @example User rescheduled the event */
            reschedulingReason?: string;
            /** @example rescheduler@example.com */
            rescheduledByEmail?: string;
            /**
             * @description UID of the previous booking from which this booking was rescheduled.
             * @example previous_uid_123
             */
            rescheduledFromUid?: string;
            /**
             * @description UID of the new booking to which this booking was rescheduled.
             * @example new_uid_456
             */
            rescheduledToUid?: string;
            /** @example 2024-08-13T15:30:00Z */
            start: string;
            /** @example 2024-08-13T16:30:00Z */
            end: string;
            /** @example 60 */
            duration: number;
            /**
             * @deprecated
             * @description Deprecated - rely on 'eventType' object containing the id instead.
             * @example 50
             */
            eventTypeId: number;
            eventType: components["schemas"]["EventType"];
            /**
             * @deprecated
             * @description Deprecated - rely on 'location' field instead.
             * @example https://example.com/recurring-meeting
             */
            meetingUrl?: string;
            /** @example https://example.com/meeting */
            location: string;
            /** @example true */
            absentHost: boolean;
            /** @example 2024-08-13T15:30:00Z */
            createdAt: string;
            /** @example 2024-08-13T15:30:00Z */
            updatedAt: string;
            /** @example {
             *       "key": "value"
             *     } */
            metadata?: Record<string, never>;
            /** @example 4 */
            rating?: number;
            /**
             * @description UID of ICS event.
             * @example ics_uid_123
             */
            icsUid?: string;
            attendees: components["schemas"]["SeatedAttendee"][];
            /** @example recurring_uid_987 */
            recurringBookingUid: string;
        };
        GetBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a BookingOutput object, a RecurringBookingOutput object, or an array of RecurringBookingOutput objects */
            data: components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"][] | components["schemas"]["GetSeatedBookingOutput_2024_08_13"] | components["schemas"]["GetRecurringSeatedBookingOutput_2024_08_13"] | components["schemas"]["GetRecurringSeatedBookingOutput_2024_08_13"][];
            error?: Record<string, never>;
        };
        RecordingItem: {
            /** @example 1234567890 */
            id: string;
            /** @example daily-video-room-123 */
            roomName: string;
            /** @example 1678901234 */
            startTs: number;
            /** @example completed */
            status: string;
            /** @example 10 */
            maxParticipants?: number;
            /** @example 3600 */
            duration: number;
            /** @example share-token-123 */
            shareToken: string;
            /** @example https://cal-video-recordings.s3.us-east-2.amazonaws.com/meetco/123s */
            downloadLink?: string | null;
            /** @example Error message */
            error?: string | null;
        };
        GetBookingRecordingsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            error?: Record<string, never>;
            data: components["schemas"]["RecordingItem"][];
        };
        GetBookingTranscriptsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @example [
             *       "https://transcript1.com",
             *       "https://transcript2.com"
             *     ] */
            data: string[];
            error?: Record<string, never>;
        };
        GetBookingsOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Array of booking data, which can contain either BookingOutput objects or RecurringBookingOutput objects */
            data: (components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"] | components["schemas"]["GetSeatedBookingOutput_2024_08_13"] | components["schemas"]["GetRecurringSeatedBookingOutput_2024_08_13"])[];
            pagination: components["schemas"]["PaginationMetaDto"];
            error?: Record<string, never>;
        };
        RescheduleBookingInput_2024_08_13: {
            /**
             * @description Start time in ISO 8601 format for the new booking
             * @example 2024-08-13T10:00:00Z
             */
            start: string;
            /** @description Email of the person who is rescheduling the booking - only needed when rescheduling a booking that requires a confirmation.
             *     If event type owner email is provided then rescheduled booking will be automatically confirmed. If attendee email or no email is passed then the event type
             *     owner will have to confirm the rescheduled booking. */
            rescheduledBy?: string;
            /**
             * @description Reason for rescheduling the booking
             * @example User requested reschedule
             */
            reschedulingReason?: string;
        };
        RescheduleSeatedBookingInput_2024_08_13: {
            /**
             * @description Start time in ISO 8601 format for the new booking
             * @example 2024-08-13T10:00:00Z
             */
            start: string;
            /** @description Email of the person who is rescheduling the booking - only needed when rescheduling a booking that requires a confirmation.
             *     If event type owner email is provided then rescheduled booking will be automatically confirmed. If attendee email or no email is passed then the event type
             *     owner will have to confirm the rescheduled booking. */
            rescheduledBy?: string;
            /**
             * @description Uid of the specific seat within booking.
             * @example 3be561a9-31f1-4b8e-aefc-9d9a085f0dd1
             */
            seatUid: string;
        };
        RescheduleBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a BookingOutput object or a RecurringBookingOutput object */
            data: components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"] | components["schemas"]["CreateSeatedBookingOutput_2024_08_13"] | components["schemas"]["CreateRecurringSeatedBookingOutput_2024_08_13"];
        };
        CancelBookingInput_2024_08_13: {
            /** @example User requested cancellation */
            cancellationReason?: string;
            /** @description For recurring non-seated booking - if true, cancel booking with the bookingUid of the individual recurrence and all recurrences that come after it. */
            cancelSubsequentBookings?: boolean;
        };
        CancelSeatedBookingInput_2024_08_13: {
            /**
             * @description Uid of the specific seat within booking.
             * @example 3be561a9-31f1-4b8e-aefc-9d9a085f0dd1
             */
            seatUid: string;
        };
        CancelBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a BookingOutput object, a RecurringBookingOutput object, or an array of RecurringBookingOutput objects */
            data: components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"][] | components["schemas"]["GetSeatedBookingOutput_2024_08_13"] | components["schemas"]["GetRecurringSeatedBookingOutput_2024_08_13"] | components["schemas"]["GetRecurringSeatedBookingOutput_2024_08_13"][];
        };
        MarkAbsentAttendee: {
            email: string;
            absent: boolean;
        };
        MarkAbsentBookingInput_2024_08_13: {
            /**
             * @description Whether the host was absent
             * @example false
             */
            host?: boolean;
            attendees?: components["schemas"]["MarkAbsentAttendee"][];
        };
        MarkAbsentBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a BookingOutput object or a RecurringBookingOutput object */
            data: components["schemas"]["BookingOutput_2024_08_13"] | components["schemas"]["RecurringBookingOutput_2024_08_13"];
        };
        ReassignedToDto: {
            /** @example 123 */
            id: number;
            /** @example John Doe */
            name: string;
            /** @example john.doe@example.com */
            email: string;
        };
        ReassignBookingOutput_2024_08_13: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            /** @description Booking data, which can be either a ReassignAutoBookingOutput object or a ReassignManualBookingOutput object */
            data: components["schemas"]["ReassignBookingOutput_2024_08_13"] & components["schemas"]["ReassignBookingOutput_2024_08_13"];
        };
        ReassignToUserBookingInput_2024_08_13: {
            /**
             * @description Reason for reassigning the booking
             * @example Host has to take another call
             */
            reason?: string;
        };
        DeclineBookingInput_2024_08_13: {
            /**
             * @description Reason for declining a booking that requires a confirmation
             * @example Host has to take another call
             */
            reason?: string;
        };
        CalendarLink: {
            /** @description The label of the calendar link */
            label: string;
            /** @description The link to the calendar */
            link: string;
        };
        CalendarLinksOutput_2024_08_13: {
            /**
             * @description The status of the request, always 'success' for successful responses
             * @example success
             */
            status: Record<string, never>;
            /** @description Calendar links for the booking */
            data: components["schemas"]["CalendarLink"][];
        };
        BookingReference: {
            /** @description The type of the booking reference */
            type: string;
            /** @description The event uid of the booking */
            eventUid: string;
            /** @description The id of the calendar the event is created in */
            destinationCalendarId: string | null;
            /** @description The id of the booking reference */
            id: number;
        };
        BookingReferencesOutput_2024_08_13: {
            /**
             * @description The status of the request, always 'success' for successful responses
             * @example success
             */
            status: Record<string, never>;
            /** @description Booking References */
            data: components["schemas"]["BookingReference"][];
        };
        CreateTeamMembershipInput: {
            userId: number;
            /** @default false */
            accepted: boolean;
            /**
             * @default MEMBER
             * @enum {string}
             */
            role: "MEMBER" | "OWNER" | "ADMIN";
            /** @default false */
            disableImpersonation: boolean;
        };
        CreateTeamMembershipOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        GetTeamMembershipOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        GetTeamMembershipsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        UpdateTeamMembershipInput: {
            accepted?: boolean;
            /** @enum {string} */
            role?: "MEMBER" | "OWNER" | "ADMIN";
            disableImpersonation?: boolean;
        };
        UpdateTeamMembershipOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        DeleteTeamMembershipOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["TeamMembershipOutput"];
        };
        UserWebhookOutputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate: string;
            userId: number;
            id: number;
            triggers: Record<string, never>[];
            subscriberUrl: string;
            active: boolean;
            secret?: string;
        };
        UserWebhookOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["UserWebhookOutputDto"];
        };
        UserWebhooksOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["UserWebhookOutputDto"][];
        };
        EventTypeWebhookOutputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate: string;
            eventTypeId: number;
            id: number;
            triggers: Record<string, never>[];
            subscriberUrl: string;
            active: boolean;
            secret?: string;
        };
        EventTypeWebhookOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeWebhookOutputDto"];
        };
        EventTypeWebhooksOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["EventTypeWebhookOutputDto"][];
        };
        DeleteManyWebhooksOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: string;
        };
        OAuthClientWebhookOutputDto: {
            /**
             * @description The template of the payload that will be sent to the subscriberUrl, check cal.com/docs/core-features/webhooks for more information
             * @example {"content":"A new event has been scheduled","type":"{{type}}","name":"{{title}}","organizer":"{{organizer.name}}","booker":"{{attendees.0.name}}"}
             */
            payloadTemplate: string;
            oAuthClientId: string;
            id: number;
            triggers: Record<string, never>[];
            subscriberUrl: string;
            active: boolean;
            secret?: string;
        };
        OAuthClientWebhookOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OAuthClientWebhookOutputDto"];
        };
        OAuthClientWebhooksOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["OAuthClientWebhookOutputDto"][];
        };
        DestinationCalendarsInputBodyDto: {
            /**
             * @description The calendar service you want to integrate, as returned by the /calendars endpoint
             * @example apple_calendar
             * @enum {string}
             */
            integration: "apple_calendar" | "google_calendar" | "office365_calendar";
            /**
             * @description Unique identifier used to represent the specific calendar, as returned by the /calendars endpoint
             * @example https://caldav.icloud.com/26962146906/calendars/1644422A-1945-4438-BBC0-4F0Q23A57R7S/
             */
            externalId: string;
            delegationCredentialId?: string;
        };
        DestinationCalendarsOutputDto: {
            userId: number;
            integration: string;
            externalId: string;
            credentialId: number | null;
        };
        DestinationCalendarsOutputResponseDto: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["DestinationCalendarsOutputDto"];
        };
        /**
         * @description Host's response to the invitation
         * @enum {string}
         */
        CalendarEventResponseStatus: "accepted" | "pending" | "declined" | "needsAction";
        CalendarEventAttendee: {
            /** @description Email address of the attendee */
            email: string;
            /** @description Display name of the attendee */
            name?: string;
            /** @example accepted */
            responseStatus?: components["schemas"]["CalendarEventResponseStatus"];
            /** @description Indicates if this attendee is the current user */
            self?: boolean | null;
            /** @description Indicates if this attendee's attendance is optional */
            optional?: boolean | null;
        };
        /**
         * @description Status of the event (accepted, pending, declined, cancelled)
         * @enum {string}
         */
        CalendarEventStatus: "accepted" | "pending" | "declined" | "cancelled";
        CalendarEventHost: {
            /** @description Email address of the event host */
            email: string;
            /** @description Display name of the event host */
            name?: string | null;
            /** @example accepted */
            responseStatus?: components["schemas"]["CalendarEventResponseStatus"];
        };
        /**
         * @description Calendar integration source (e.g., Google Calendar, Office 365, Apple Calendar). Currently only Google Calendar is supported.
         * @enum {string}
         */
        CalendarSource: "google" | "office365" | "apple";
        UnifiedCalendarEventOutput: {
            /** @description Start date and time of the calendar event with timezone information */
            start: {
                /** Format: date-time */
                time?: string;
                timeZone?: string;
            };
            /** @description End date and time of the calendar event with timezone information */
            end: {
                /** Format: date-time */
                time?: string;
                timeZone?: string;
            };
            /** @description Unique identifier of the calendar event */
            id: string;
            /** @description Title of the calendar event */
            title: string;
            /** @description Detailed description of the calendar event */
            description?: string | null;
            /** @description Conference locations with entry points (video, phone, sip, more) */
            locations?: unknown[] | null;
            /** @description List of attendees with their response status */
            attendees?: components["schemas"]["CalendarEventAttendee"][] | null;
            /** @example accepted */
            status?: components["schemas"]["CalendarEventStatus"];
            /** @description Information about the event hosts (organizers) */
            hosts?: components["schemas"]["CalendarEventHost"][] | null;
            /** @example google */
            source: components["schemas"]["CalendarSource"];
        };
        GetUnifiedCalendarEventOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["UnifiedCalendarEventOutput"];
        };
        RequestEmailVerificationInput: {
            /**
             * @description Email to verify.
             * @example acme@example.com
             */
            email: string;
        };
        RequestEmailVerificationOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        RequestPhoneVerificationInput: {
            /**
             * @description Phone number to verify.
             * @example +372 5555 6666
             */
            phone: string;
        };
        RequestPhoneVerificationOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
        };
        VerifyEmailInput: {
            /**
             * @description Email to verify.
             * @example example@acme.com
             */
            email: string;
            /**
             * @description verification code sent to the email to verify
             * @example 1ABG2C
             */
            code: string;
        };
        WorkingHours: {
            days: number[];
            startTime: number;
            endTime: number;
            userId?: number | null;
        };
        AvailabilityModel: {
            id: number;
            userId?: number | null;
            eventTypeId?: number | null;
            days: number[];
            /** Format: date-time */
            startTime: string;
            /** Format: date-time */
            endTime: string;
            /** Format: date-time */
            date?: string | null;
            scheduleId?: number | null;
        };
        ScheduleOutput: {
            id: number;
            name: string;
            isManaged: boolean;
            workingHours: components["schemas"]["WorkingHours"][];
            schedule: components["schemas"]["AvailabilityModel"][];
            availability: unknown[][];
            timeZone: string;
            dateOverrides?: Record<string, never>[];
            isDefault: boolean;
            isLastSchedule: boolean;
            readOnly: boolean;
        };
        UserVerifiedEmailOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        VerifyPhoneInput: {
            /**
             * @description phone number to verify.
             * @example +37255556666
             */
            phone: string;
            /**
             * @description verification code sent to the phone number to verify
             * @example 1ABG2C
             */
            code: string;
        };
        UserVerifiedPhoneOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        UserVerifiedEmailsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        UserVerifiedPhonesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        TeamVerifiedEmailOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        TeamVerifiedPhoneOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        TeamVerifiedEmailsOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
        TeamVerifiedPhonesOutput: {
            /**
             * @example success
             * @enum {string}
             */
            status: "success" | "error";
            data: components["schemas"]["ScheduleOutput"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    OAuthClientUsersController_getManagedUsers: {
        parameters: {
            query?: {
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                limit?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                offset?: number;
                /**
                 * @description Filter managed users by email. If you want to filter by multiple emails, separate them with a comma.
                 * @example ?emails=email1@example.com,email2@example.com
                 */
                emails?: string[];
            };
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedUsersOutput"];
                };
            };
        };
    };
    OAuthClientUsersController_createUser: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateManagedUserInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateManagedUserOutput"];
                };
            };
        };
    };
    OAuthClientUsersController_getUserById: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedUserOutput"];
                };
            };
        };
    };
    OAuthClientUsersController_deleteUser: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedUserOutput"];
                };
            };
        };
    };
    OAuthClientUsersController_updateUser: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateManagedUserInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedUserOutput"];
                };
            };
        };
    };
    OAuthClientUsersController_forceRefresh: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                userId: number;
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KeysResponseDto"];
                };
            };
        };
    };
    OAuthFlowController_refreshTokens: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key. */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefreshTokenInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KeysResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_getOAuthClientWebhooks: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClientWebhooksOutputResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_createOAuthClientWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClientWebhookOutputResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_deleteAllOAuthClientWebhooks: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteManyWebhooksOutputResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_getOAuthClientWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClientWebhookOutputResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_deleteOAuthClientWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClientWebhookOutputResponseDto"];
                };
            };
        };
    };
    OAuthClientWebhooksController_updateOAuthClientWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description OAuth client secret key */
                "x-cal-secret-key": string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWebhookInputDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OAuthClientWebhookOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsAttributesController_getOrganizationAttributes: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrganizationAttributesOutput"];
                };
            };
        };
    };
    OrganizationsAttributesController_createOrganizationAttribute: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrganizationAttributeInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateOrganizationAttributesOutput"];
                };
            };
        };
    };
    OrganizationsAttributesController_getOrganizationAttribute: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSingleAttributeOutput"];
                };
            };
        };
    };
    OrganizationsAttributesController_deleteOrganizationAttribute: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteOrganizationAttributesOutput"];
                };
            };
        };
    };
    OrganizationsAttributesController_updateOrganizationAttribute: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrganizationAttributeInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateOrganizationAttributesOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_getOrganizationAttributeOptions: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetAllAttributeOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_createOrganizationAttributeOption: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrganizationAttributeOptionInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateAttributeOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_deleteOrganizationAttributeOption: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
                optionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteAttributeOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_updateOrganizationAttributeOption: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
                optionId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrganizationAttributeOptionInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateAttributeOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_getOrganizationAttributeAssignedOptions: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /**
                 * @description Filter by assigned attribute option ids. ids must be separated by a comma.
                 * @example ?assignedOptionIds=aaaaaaaa-bbbb-cccc-dddd-eeeeee1eee,aaaaaaaa-bbbb-cccc-dddd-eeeeee2eee
                 */
                assignedOptionIds?: string[];
                /**
                 * @description Filter by teamIds. Team ids must be separated by a comma.
                 * @example ?teamIds=100,200
                 */
                teamIds?: number[];
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetAllAttributeAssignedOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_getOrganizationAttributeAssignedOptionsBySlug: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /**
                 * @description Filter by assigned attribute option ids. ids must be separated by a comma.
                 * @example ?assignedOptionIds=aaaaaaaa-bbbb-cccc-dddd-eeeeee1eee,aaaaaaaa-bbbb-cccc-dddd-eeeeee2eee
                 */
                assignedOptionIds?: string[];
                /**
                 * @description Filter by teamIds. Team ids must be separated by a comma.
                 * @example ?teamIds=100,200
                 */
                teamIds?: number[];
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                attributeSlug: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetAllAttributeAssignedOptionOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_getOrganizationAttributeOptionsForUser: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOptionUserOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_assignOrganizationAttributeOptionToUser: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AssignOrganizationAttributeOptionToUserInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AssignOptionUserOutput"];
                };
            };
        };
    };
    OrganizationsAttributesOptionsController_unassignOrganizationAttributeOptionFromUser: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                userId: number;
                attributeOptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnassignOptionUserOutput"];
                };
            };
        };
    };
    OrganizationsBookingsController_getAllOrgTeamBookings: {
        parameters: {
            query?: {
                /**
                 * @description Filter bookings by status. If you want to filter by multiple statuses, separate them with a comma.
                 * @example ?status=upcoming,past
                 */
                status?: ("upcoming" | "recurring" | "past" | "cancelled" | "unconfirmed")[];
                /**
                 * @description Filter bookings by the attendee's email address.
                 * @example example@domain.com
                 */
                attendeeEmail?: string;
                /**
                 * @description Filter bookings by the attendee's name.
                 * @example John Doe
                 */
                attendeeName?: string;
                /**
                 * @description Filter bookings by the booking Uid.
                 * @example 2NtaeaVcKfpmSZ4CthFdfk
                 */
                bookingUid?: string;
                /**
                 * @description Filter bookings by event type ids belonging to the user. Event type ids must be separated by a comma.
                 * @example ?eventTypeIds=100,200
                 */
                eventTypeIds?: string;
                /**
                 * @description Filter bookings by event type id belonging to the user.
                 * @example ?eventTypeId=100
                 */
                eventTypeId?: string;
                /**
                 * @description Filter bookings by team ids that user is part of. Team ids must be separated by a comma.
                 * @example ?teamIds=50,60
                 */
                teamsIds?: string;
                /**
                 * @description Filter bookings by team id that user is part of
                 * @example ?teamId=50
                 */
                teamId?: string;
                /**
                 * @description Filter bookings with start after this date string.
                 * @example ?afterStart=2025-03-07T10:00:00.000Z
                 */
                afterStart?: string;
                /**
                 * @description Filter bookings with end before this date string.
                 * @example ?beforeEnd=2025-03-07T11:00:00.000Z
                 */
                beforeEnd?: string;
                /**
                 * @description Filter bookings that have been created after this date string.
                 * @example ?afterCreatedAt=2025-03-07T10:00:00.000Z
                 */
                afterCreatedAt?: string;
                /**
                 * @description Filter bookings that have been created before this date string.
                 * @example ?beforeCreatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeCreatedAt?: string;
                /**
                 * @description Filter bookings that have been updated after this date string.
                 * @example ?afterUpdatedAt=2025-03-07T10:00:00.000Z
                 */
                afterUpdatedAt?: string;
                /**
                 * @description Filter bookings that have been updated before this date string.
                 * @example ?beforeUpdatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeUpdatedAt?: string;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
                /**
                 * @description Sort results by their creation time (when booking was made) in ascending or descending order.
                 * @example ?sortCreated=asc OR ?sortCreated=desc
                 */
                sortCreated?: "asc" | "desc";
                /**
                 * @description Sort results by their updated time (for example when booking status changes) in ascending or descending order.
                 * @example ?sortUpdated=asc OR ?sortUpdated=desc
                 */
                sortUpdatedAt?: "asc" | "desc";
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                take?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                skip?: number;
                /**
                 * @description Filter bookings by ids of users within your organization.
                 * @example ?userIds=100,200
                 */
                userIds?: string;
            };
            header?: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingsOutput_2024_08_13"];
                };
            };
        };
    };
    OrganizationsDelegationCredentialController_createDelegationCredential: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateDelegationCredentialInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateDelegationCredentialOutput"];
                };
            };
        };
    };
    OrganizationsDelegationCredentialController_updateDelegationCredential: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                credentialId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateDelegationCredentialInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateDelegationCredentialOutput"];
                };
            };
        };
    };
    OrganizationsMembershipsController_getAllMemberships: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetAllOrgMemberships"];
                };
            };
        };
    };
    OrganizationsMembershipsController_createMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrgMembershipDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateOrgMembershipOutput"];
                };
            };
        };
    };
    OrganizationsMembershipsController_getOrgMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrgMembership"];
                };
            };
        };
    };
    OrganizationsMembershipsController_deleteMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteOrgMembership"];
                };
            };
        };
    };
    OrganizationsMembershipsController_updateMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrgMembershipDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateOrgMembership"];
                };
            };
        };
    };
    OrganizationsRoutingFormsController_getOrganizationRoutingForms: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /** @description Sort by creation time */
                sortCreatedAt?: "asc" | "desc";
                /** @description Sort by update time */
                sortUpdatedAt?: "asc" | "desc";
                /** @description Filter by responses created after this date */
                afterCreatedAt?: string;
                /** @description Filter by responses created before this date */
                beforeCreatedAt?: string;
                /** @description Filter by responses created after this date */
                afterUpdatedAt?: string;
                /** @description Filter by responses updated before this date */
                beforeUpdatedAt?: string;
                /** @description Filter by responses routed to a specific booking */
                routedToBookingUid?: string;
                /**
                 * @description Filter by teamIds. Team ids must be separated by a comma.
                 * @example ?teamIds=100,200
                 */
                teamIds?: number[];
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetRoutingFormsOutput"];
                };
            };
        };
    };
    OrganizationsRoutingFormsResponsesController_getRoutingFormResponses: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /** @description Sort by creation time */
                sortCreatedAt?: "asc" | "desc";
                /** @description Sort by update time */
                sortUpdatedAt?: "asc" | "desc";
                /** @description Filter by responses created after this date */
                afterCreatedAt?: string;
                /** @description Filter by responses created before this date */
                beforeCreatedAt?: string;
                /** @description Filter by responses created after this date */
                afterUpdatedAt?: string;
                /** @description Filter by responses updated before this date */
                beforeUpdatedAt?: string;
                /** @description Filter by responses routed to a specific booking */
                routedToBookingUid?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                routingFormId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetRoutingFormResponsesOutput"];
                };
            };
        };
    };
    OrganizationsRoutingFormsResponsesController_createRoutingFormResponse: {
        parameters: {
            query: {
                /**
                 * @description
                 *           Time starting from which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to start of day or specify hours:
                 *           2024-08-13 (will have hours 00:00:00 aka at very beginning of the date) or you can specify hours manually like 2024-08-13T09:00:00Z
                 *
                 * @example 2050-09-05
                 */
                start: string;
                /**
                 * @description
                 *           Time until which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to end of day or specify hours:
                 *           2024-08-20 (will have hours 23:59:59 aka at the very end of the date) or you can specify hours manually like 2024-08-20T18:00:00Z
                 * @example 2050-09-06
                 */
                end: string;
                /**
                 * @description Time zone in which the available slots should be returned. Defaults to UTC.
                 * @example Europe/Rome
                 */
                timeZone?: string;
                /**
                 * @description If event type has multiple possible durations then you can specify the desired duration here. Also, if you are fetching slots for a dynamic event then you can specify the duration her which defaults to 30, meaning that returned slots will be each 30 minutes long.
                 * @example 60
                 */
                duration?: number;
                /**
                 * @description Format of slot times in response. Use 'range' to get start and end times.
                 * @example range
                 */
                format?: "range" | "time";
                /**
                 * @description The unique identifier of the booking being rescheduled. When provided will ensure that the original booking time appears within the returned available slots when rescheduling.
                 * @example abc123def456
                 */
                bookingUidToReschedule?: string;
                /**
                 * @description Whether to queue the form response.
                 * @example true
                 */
                queueResponse?: boolean;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                routingFormId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateRoutingFormResponseOutput"];
                };
            };
        };
    };
    OrganizationsRoutingFormsResponsesController_updateRoutingFormResponse: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                routingFormId: string;
                responseId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateRoutingFormResponseInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateRoutingFormResponseOutput"];
                };
            };
        };
    };
    OrganizationsSchedulesController_getOrganizationSchedules: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSchedulesOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsTeamsController_getAllTeams: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamsOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsController_createTeam: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrgTeamDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsController_getMyTeams: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgMeTeamsOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsController_getTeam: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsController_deleteTeam: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsController_updateTeam: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrgTeamDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsBookingsController_getAllOrgTeamBookings: {
        parameters: {
            query?: {
                /**
                 * @description Filter bookings by status. If you want to filter by multiple statuses, separate them with a comma.
                 * @example ?status=upcoming,past
                 */
                status?: ("upcoming" | "recurring" | "past" | "cancelled" | "unconfirmed")[];
                /**
                 * @description Filter bookings by the attendee's email address.
                 * @example example@domain.com
                 */
                attendeeEmail?: string;
                /**
                 * @description Filter bookings by the attendee's name.
                 * @example John Doe
                 */
                attendeeName?: string;
                /**
                 * @description Filter bookings by event type ids belonging to the team. Event type ids must be separated by a comma.
                 * @example ?eventTypeIds=100,200
                 */
                eventTypeIds?: string;
                /**
                 * @description Filter bookings by event type id belonging to the team.
                 * @example ?eventTypeId=100
                 */
                eventTypeId?: string;
                /**
                 * @description Filter bookings with start after this date string.
                 * @example ?afterStart=2025-03-07T10:00:00.000Z
                 */
                afterStart?: string;
                /**
                 * @description Filter bookings with end before this date string.
                 * @example ?beforeEnd=2025-03-07T11:00:00.000Z
                 */
                beforeEnd?: string;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
                /**
                 * @description Sort results by their creation time (when booking was made) in ascending or descending order.
                 * @example ?sortCreated=asc OR ?sortCreated=desc
                 */
                sortCreated?: "asc" | "desc";
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                take?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingsOutput_2024_08_13"];
                };
            };
        };
    };
    OrganizationsTeamsBookingsController_getBookingReferences: {
        parameters: {
            query?: {
                /**
                 * @description Filter booking references by type
                 * @example google_calendar
                 */
                type?: "google_calendar" | "office365_calendar" | "daily_video" | "google_video" | "office365_video" | "zoom_video";
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingReferencesOutput_2024_08_13"];
                };
            };
        };
    };
    OrganizationsConferencingController_connectTeamApp: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
                orgId: number;
                /** @description Conferencing application type */
                app: "google-meet";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_getTeamOAuthUrl: {
        parameters: {
            query: {
                returnTo: string;
                onErrorReturnTo: string;
            };
            header: {
                Authorization: string;
            };
            path: {
                teamId: string;
                orgId: string;
                /** @description Conferencing application type */
                app: "zoom" | "msteams";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetConferencingAppsOauthUrlResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_listTeamConferencingApps: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConferencingAppsOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_setTeamDefaultApp: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
                /** @description Conferencing application type */
                app: "google-meet" | "zoom" | "msteams" | "daily-video";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetDefaultConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_getTeamDefaultApp: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
                /** @description Conferencing application type */
                app: "google-meet" | "zoom" | "msteams" | "daily-video";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetDefaultConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_disconnectTeamApp: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
                /** @description Conferencing application type */
                app: "google-meet" | "zoom" | "msteams";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DisconnectConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsConferencingController_saveTeamOauthCredentials: {
        parameters: {
            query: {
                state: string;
                code: string;
            };
            header?: never;
            path: {
                teamId: number;
                orgId: number;
                app: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsEventTypesController_getTeamEventTypes: {
        parameters: {
            query?: {
                /** @description Slug of team event type to return. */
                eventSlug?: string;
                /** @description Specifies the maximum number of hosts to include in the response. This limit helps optimize performance. If not provided, all Hosts will be fetched. */
                hostsLimit?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamEventTypesOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_createTeamEventType: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTeamEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateTeamEventTypeOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_getTeamEventType: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamEventTypeOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_deleteTeamEventType: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteTeamEventTypeOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_updateTeamEventType: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTeamEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateTeamEventTypeOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_createPhoneCall: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                eventTypeId: number;
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePhoneCallInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreatePhoneCallOutput"];
                };
            };
        };
    };
    OrganizationsEventTypesController_getTeamsEventTypes: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamEventTypesOutput"];
                };
            };
        };
    };
    OrganizationsTeamsMembershipsController_getAllOrgTeamMemberships: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamMembershipsOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsMembershipsController_createOrgTeamMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrgTeamMembershipDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamMembershipOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsMembershipsController_getOrgTeamMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamMembershipOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsMembershipsController_deleteOrgTeamMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamMembershipOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsMembershipsController_updateOrgTeamMembership: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrgTeamMembershipDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamMembershipOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsRoutingFormsController_getTeamRoutingForms: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /** @description Sort by creation time */
                sortCreatedAt?: "asc" | "desc";
                /** @description Sort by update time */
                sortUpdatedAt?: "asc" | "desc";
                /** @description Filter by responses created after this date */
                afterCreatedAt?: string;
                /** @description Filter by responses created before this date */
                beforeCreatedAt?: string;
                /** @description Filter by responses created after this date */
                afterUpdatedAt?: string;
                /** @description Filter by responses updated before this date */
                beforeUpdatedAt?: string;
                /** @description Filter by responses routed to a specific booking */
                routedToBookingUid?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetRoutingFormsOutput"];
                };
            };
        };
    };
    OrganizationsTeamsRoutingFormsResponsesController_getRoutingFormResponses: {
        parameters: {
            query?: {
                /** @description Number of responses to skip */
                skip?: number;
                /** @description Number of responses to take */
                take?: number;
                /** @description Sort by creation time */
                sortCreatedAt?: "asc" | "desc";
                /** @description Sort by update time */
                sortUpdatedAt?: "asc" | "desc";
                /** @description Filter by responses created after this date */
                afterCreatedAt?: string;
                /** @description Filter by responses created before this date */
                beforeCreatedAt?: string;
                /** @description Filter by responses created after this date */
                afterUpdatedAt?: string;
                /** @description Filter by responses updated before this date */
                beforeUpdatedAt?: string;
                /** @description Filter by responses routed to a specific booking */
                routedToBookingUid?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                routingFormId: string;
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetRoutingFormResponsesOutput"];
                };
            };
        };
    };
    OrganizationsTeamsRoutingFormsResponsesController_createRoutingFormResponse: {
        parameters: {
            query: {
                /**
                 * @description
                 *           Time starting from which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to start of day or specify hours:
                 *           2024-08-13 (will have hours 00:00:00 aka at very beginning of the date) or you can specify hours manually like 2024-08-13T09:00:00Z
                 *
                 * @example 2050-09-05
                 */
                start: string;
                /**
                 * @description
                 *           Time until which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to end of day or specify hours:
                 *           2024-08-20 (will have hours 23:59:59 aka at the very end of the date) or you can specify hours manually like 2024-08-20T18:00:00Z
                 * @example 2050-09-06
                 */
                end: string;
                /**
                 * @description Time zone in which the available slots should be returned. Defaults to UTC.
                 * @example Europe/Rome
                 */
                timeZone?: string;
                /**
                 * @description If event type has multiple possible durations then you can specify the desired duration here. Also, if you are fetching slots for a dynamic event then you can specify the duration her which defaults to 30, meaning that returned slots will be each 30 minutes long.
                 * @example 60
                 */
                duration?: number;
                /**
                 * @description Format of slot times in response. Use 'range' to get start and end times.
                 * @example range
                 */
                format?: "range" | "time";
                /**
                 * @description The unique identifier of the booking being rescheduled. When provided will ensure that the original booking time appears within the returned available slots when rescheduling.
                 * @example abc123def456
                 */
                bookingUidToReschedule?: string;
                /**
                 * @description Whether to queue the form response.
                 * @example true
                 */
                queueResponse?: boolean;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                orgId: number;
                teamId: number;
                routingFormId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateRoutingFormResponseOutput"];
                };
            };
        };
    };
    OrganizationsTeamsRoutingFormsResponsesController_updateRoutingFormResponse: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                routingFormId: string;
                responseId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateRoutingFormResponseInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateRoutingFormResponseOutput"];
                };
            };
        };
    };
    OrganizationsStripeController_getTeamStripeConnectUrl: {
        parameters: {
            query: {
                returnTo: string;
                onErrorReturnTo: string;
            };
            header: {
                Authorization: string;
            };
            path: {
                teamId: string;
                orgId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripConnectOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsStripeController_checkTeamStripeConnection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripCredentialsCheckOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsStripeController_save: {
        parameters: {
            query: {
                state: string;
                code: string;
            };
            header?: never;
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripCredentialsSaveOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsTeamsSchedulesController_getUserSchedules: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSchedulesOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationTeamWorkflowsController_getWorkflows: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetWorkflowsOutput"];
                };
            };
        };
    };
    OrganizationTeamWorkflowsController_createWorkflow: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWorkflowDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetWorkflowOutput"];
                };
            };
        };
    };
    OrganizationTeamWorkflowsController_getWorkflowById: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                workflowId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetWorkflowOutput"];
                };
            };
        };
    };
    OrganizationTeamWorkflowsController_deleteWorkflow: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                workflowId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationTeamWorkflowsController_updateWorkflow: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                teamId: number;
                workflowId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWorkflowDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetWorkflowOutput"];
                };
            };
        };
    };
    OrganizationsUsersController_getOrganizationsUsers: {
        parameters: {
            query?: {
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                take?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                skip?: number;
                /** @description The email address or an array of email addresses to filter by */
                emails?: string[];
                /**
                 * @description Filter by assigned attribute option ids. ids must be separated by a comma.
                 * @example ?assignedOptionIds=aaaaaaaa-bbbb-cccc-dddd-eeeeee1eee,aaaaaaaa-bbbb-cccc-dddd-eeeeee2eee
                 */
                assignedOptionIds?: string[];
                /**
                 * @description Query operator used to filter assigned options, AND by default.
                 * @example NONE
                 */
                attributeQueryOperator?: "OR" | "AND" | "NONE";
                /**
                 * @description Filter by teamIds. Team ids must be separated by a comma.
                 * @example ?teamIds=100,200
                 */
                teamIds?: number[];
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrganizationUsersResponseDTO"];
                };
            };
        };
    };
    OrganizationsUsersController_createOrganizationUser: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrganizationUserInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrganizationUserOutput"];
                };
            };
        };
    };
    OrganizationsUsersController_deleteOrganizationUser: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrganizationUserOutput"];
                };
            };
        };
    };
    OrganizationsUsersController_updateOrganizationUser: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrganizationUserInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOrganizationUserOutput"];
                };
            };
        };
    };
    OrganizationsUsersBookingsController_getOrganizationUserBookings: {
        parameters: {
            query?: {
                /**
                 * @description Filter bookings by status. If you want to filter by multiple statuses, separate them with a comma.
                 * @example ?status=upcoming,past
                 */
                status?: ("upcoming" | "recurring" | "past" | "cancelled" | "unconfirmed")[];
                /**
                 * @description Filter bookings by the attendee's email address.
                 * @example example@domain.com
                 */
                attendeeEmail?: string;
                /**
                 * @description Filter bookings by the attendee's name.
                 * @example John Doe
                 */
                attendeeName?: string;
                /**
                 * @description Filter bookings by the booking Uid.
                 * @example 2NtaeaVcKfpmSZ4CthFdfk
                 */
                bookingUid?: string;
                /**
                 * @description Filter bookings by event type ids belonging to the user. Event type ids must be separated by a comma.
                 * @example ?eventTypeIds=100,200
                 */
                eventTypeIds?: string;
                /**
                 * @description Filter bookings by event type id belonging to the user.
                 * @example ?eventTypeId=100
                 */
                eventTypeId?: string;
                /**
                 * @description Filter bookings by team ids that user is part of. Team ids must be separated by a comma.
                 * @example ?teamIds=50,60
                 */
                teamsIds?: string;
                /**
                 * @description Filter bookings by team id that user is part of
                 * @example ?teamId=50
                 */
                teamId?: string;
                /**
                 * @description Filter bookings with start after this date string.
                 * @example ?afterStart=2025-03-07T10:00:00.000Z
                 */
                afterStart?: string;
                /**
                 * @description Filter bookings with end before this date string.
                 * @example ?beforeEnd=2025-03-07T11:00:00.000Z
                 */
                beforeEnd?: string;
                /**
                 * @description Filter bookings that have been created after this date string.
                 * @example ?afterCreatedAt=2025-03-07T10:00:00.000Z
                 */
                afterCreatedAt?: string;
                /**
                 * @description Filter bookings that have been created before this date string.
                 * @example ?beforeCreatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeCreatedAt?: string;
                /**
                 * @description Filter bookings that have been updated after this date string.
                 * @example ?afterUpdatedAt=2025-03-07T10:00:00.000Z
                 */
                afterUpdatedAt?: string;
                /**
                 * @description Filter bookings that have been updated before this date string.
                 * @example ?beforeUpdatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeUpdatedAt?: string;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
                /**
                 * @description Sort results by their creation time (when booking was made) in ascending or descending order.
                 * @example ?sortCreated=asc OR ?sortCreated=desc
                 */
                sortCreated?: "asc" | "desc";
                /**
                 * @description Sort results by their updated time (for example when booking status changes) in ascending or descending order.
                 * @example ?sortUpdated=asc OR ?sortUpdated=desc
                 */
                sortUpdatedAt?: "asc" | "desc";
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                take?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsUsersOOOController_getOrganizationUserOOO: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsUsersOOOController_createOrganizationUserOOO: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOutOfOfficeEntryDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsUsersOOOController_deleteOrganizationUserOOO: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                oooId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsUsersOOOController_updateOrganizationUserOOO: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
                oooId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOutOfOfficeEntryDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsUsersOOOController_getOrganizationUsersOOO: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
                /**
                 * @description Filter ooo entries by the user email address. user must be within your organization.
                 * @example example@domain.com
                 */
                email?: string;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    OrganizationsSchedulesController_getUserSchedules: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSchedulesOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsSchedulesController_createUserSchedule: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateScheduleInput_2024_06_11"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsSchedulesController_getUserSchedule: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
                scheduleId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsSchedulesController_deleteUserSchedule: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
                scheduleId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsSchedulesController_updateUserSchedule: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                userId: number;
                scheduleId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateScheduleInput_2024_06_11"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    OrganizationsWebhooksController_getAllOrganizationWebhooks: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamWebhooksOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsWebhooksController_createOrganizationWebhook: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamWebhookOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsWebhooksController_getOrganizationWebhook: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamWebhookOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsWebhooksController_deleteWebhook: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamWebhookOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsWebhooksController_updateOrgWebhook: {
        parameters: {
            query?: never;
            header?: {
                /** @description For non-platform customers - value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization?: string;
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWebhookInputDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamWebhookOutputResponseDto"];
                };
            };
        };
    };
    ApiKeysController_refresh: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefreshApiKeyInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefreshApiKeyOutput"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getBookings: {
        parameters: {
            query?: {
                /**
                 * @description Filter bookings by status. If you want to filter by multiple statuses, separate them with a comma.
                 * @example ?status=upcoming,past
                 */
                status?: ("upcoming" | "recurring" | "past" | "cancelled" | "unconfirmed")[];
                /**
                 * @description Filter bookings by the attendee's email address.
                 * @example example@domain.com
                 */
                attendeeEmail?: string;
                /**
                 * @description Filter bookings by the attendee's name.
                 * @example John Doe
                 */
                attendeeName?: string;
                /**
                 * @description Filter bookings by the booking Uid.
                 * @example 2NtaeaVcKfpmSZ4CthFdfk
                 */
                bookingUid?: string;
                /**
                 * @description Filter bookings by event type ids belonging to the user. Event type ids must be separated by a comma.
                 * @example ?eventTypeIds=100,200
                 */
                eventTypeIds?: string;
                /**
                 * @description Filter bookings by event type id belonging to the user.
                 * @example ?eventTypeId=100
                 */
                eventTypeId?: string;
                /**
                 * @description Filter bookings by team ids that user is part of. Team ids must be separated by a comma.
                 * @example ?teamIds=50,60
                 */
                teamsIds?: string;
                /**
                 * @description Filter bookings by team id that user is part of
                 * @example ?teamId=50
                 */
                teamId?: string;
                /**
                 * @description Filter bookings with start after this date string.
                 * @example ?afterStart=2025-03-07T10:00:00.000Z
                 */
                afterStart?: string;
                /**
                 * @description Filter bookings with end before this date string.
                 * @example ?beforeEnd=2025-03-07T11:00:00.000Z
                 */
                beforeEnd?: string;
                /**
                 * @description Filter bookings that have been created after this date string.
                 * @example ?afterCreatedAt=2025-03-07T10:00:00.000Z
                 */
                afterCreatedAt?: string;
                /**
                 * @description Filter bookings that have been created before this date string.
                 * @example ?beforeCreatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeCreatedAt?: string;
                /**
                 * @description Filter bookings that have been updated after this date string.
                 * @example ?afterUpdatedAt=2025-03-07T10:00:00.000Z
                 */
                afterUpdatedAt?: string;
                /**
                 * @description Filter bookings that have been updated before this date string.
                 * @example ?beforeUpdatedAt=2025-03-14T11:00:00.000Z
                 */
                beforeUpdatedAt?: string;
                /**
                 * @description Sort results by their start time in ascending or descending order.
                 * @example ?sortStart=asc OR ?sortStart=desc
                 */
                sortStart?: "asc" | "desc";
                /**
                 * @description Sort results by their end time in ascending or descending order.
                 * @example ?sortEnd=asc OR ?sortEnd=desc
                 */
                sortEnd?: "asc" | "desc";
                /**
                 * @description Sort results by their creation time (when booking was made) in ascending or descending order.
                 * @example ?sortCreated=asc OR ?sortCreated=desc
                 */
                sortCreated?: "asc" | "desc";
                /**
                 * @description Sort results by their updated time (for example when booking status changes) in ascending or descending order.
                 * @example ?sortUpdated=asc OR ?sortUpdated=desc
                 */
                sortUpdatedAt?: "asc" | "desc";
                /**
                 * @description The number of items to return
                 * @example 10
                 */
                take?: number;
                /**
                 * @description The number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingsOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_createBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        /** @description Accepts different types of booking input: Create Booking (Option 1), Create Instant Booking (Option 2), or Create Recurring Booking (Option 3) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBookingInput_2024_08_13"] | components["schemas"]["CreateInstantBookingInput_2024_08_13"] | components["schemas"]["CreateRecurringBookingInput_2024_08_13"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getBookingRecordings: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingRecordingsOutput"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getBookingTranscripts: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingTranscriptsOutput"];
                };
            };
        };
    };
    BookingsController_2024_08_13_rescheduleBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        /** @description Accepts different types of reschedule booking input: Reschedule Booking (Option 1) or Reschedule Seated Booking (Option 2) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RescheduleBookingInput_2024_08_13"] | components["schemas"]["RescheduleSeatedBookingInput_2024_08_13"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RescheduleBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_cancelBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        /** @description Accepts different types of cancel booking input: Cancel Booking (Option 1) or Cancel Seated Booking (Option 2) */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CancelBookingInput_2024_08_13"] | components["schemas"]["CancelSeatedBookingInput_2024_08_13"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_markNoShow: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MarkAbsentBookingInput_2024_08_13"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MarkAbsentBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_reassignBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReassignBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_reassignBookingToUser: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
                userId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReassignToUserBookingInput_2024_08_13"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReassignBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_confirmBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_declineBooking: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DeclineBookingInput_2024_08_13"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBookingOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getCalendarLinks: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CalendarLinksOutput_2024_08_13"];
                };
            };
        };
    };
    BookingsController_2024_08_13_getBookingReferences: {
        parameters: {
            query?: {
                /**
                 * @description Filter booking references by type
                 * @example google_calendar
                 */
                type?: "google_calendar" | "office365_calendar" | "daily_video" | "google_video" | "office365_video" | "zoom_video";
            };
            header: {
                /** @description Must be set to 2024-08-13 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                bookingUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingReferencesOutput_2024_08_13"];
                };
            };
        };
    };
    CalUnifiedCalendarsController_getCalendarEventDetails: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                calendar: "google";
                /** @description The Google Calendar event ID. You can retrieve this by getting booking references from the following endpoints:
                 *
                 *     - For team events: https://cal.com/docs/api-reference/v2/orgs-teams-bookings/get-booking-references-for-a-booking
                 *
                 *     - For user events: https://cal.com/docs/api-reference/v2/bookings/get-booking-references-for-a-booking */
                eventUid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetUnifiedCalendarEventOutput"];
                };
            };
        };
    };
    CalendarsController_createIcsFeed: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateIcsFeedInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateIcsFeedOutputResponseDto"];
                };
            };
        };
    };
    CalendarsController_checkIcsFeed: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    CalendarsController_getBusyTimes: {
        parameters: {
            query: {
                /**
                 * @description The timezone of the logged in user represented as a string
                 * @example America/New_York
                 */
                loggedInUsersTz: string;
                /**
                 * @description The starting date for the busy times query
                 * @example 2023-10-01
                 */
                dateFrom?: string;
                /**
                 * @description The ending date for the busy times query
                 * @example 2023-10-31
                 */
                dateTo?: string;
                credentialId: number;
                externalId: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetBusyTimesOutput"];
                };
            };
        };
    };
    CalendarsController_getCalendars: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConnectedCalendarsOutput"];
                };
            };
        };
    };
    CalendarsController_redirect: {
        parameters: {
            query: {
                isDryRun: boolean;
                /** @description Redirect URL after successful calendar authorization. */
                redir?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                calendar: "office365" | "google";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    CalendarsController_save: {
        parameters: {
            query: {
                state: string;
                code: string;
            };
            header?: never;
            path: {
                calendar: "office365" | "google";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CalendarsController_syncCredentials: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                calendar: "apple";
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCalendarCredentialsInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CalendarsController_check: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                calendar: "apple" | "google" | "office365";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    CalendarsController_deleteCalendarCredentials: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                calendar: "apple" | "google" | "office365";
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DeleteCalendarCredentialsInputBodyDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeletedCalendarCredentialsOutputResponseDto"];
                };
            };
        };
    };
    ConferencingController_connect: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                /** @description Conferencing application type */
                app: "google-meet";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    ConferencingController_redirect: {
        parameters: {
            query: {
                returnTo: string;
                onErrorReturnTo: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                /** @description Conferencing application type */
                app: "zoom" | "msteams";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetConferencingAppsOauthUrlResponseDto"];
                };
            };
        };
    };
    ConferencingController_save: {
        parameters: {
            query: {
                state: string;
                code: string;
            };
            header?: never;
            path: {
                /** @description Conferencing application type */
                app: "zoom" | "msteams";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ConferencingController_listInstalledConferencingApps: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConferencingAppsOutputResponseDto"];
                };
            };
        };
    };
    ConferencingController_default: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                /** @description Conferencing application type */
                app: "google-meet" | "zoom" | "msteams" | "daily-video";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetDefaultConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    ConferencingController_getDefault: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetDefaultConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    ConferencingController_disconnect: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                /** @description Conferencing application type */
                app: "google-meet" | "zoom" | "msteams";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DisconnectConferencingAppOutputResponseDto"];
                };
            };
        };
    };
    DestinationCalendarsController_updateDestinationCalendars: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DestinationCalendarsInputBodyDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DestinationCalendarsOutputResponseDto"];
                };
            };
        };
    };
    EventTypesController_2024_06_14_getEventTypes: {
        parameters: {
            query?: {
                /** @description The username of the user to get event types for. If only username provided will get all event types. */
                username?: string;
                /** @description Slug of event type to return. Notably, if eventSlug is provided then username must be provided too, because multiple users can have event with same slug. */
                eventSlug?: string;
                /** @description Get dynamic event type for multiple usernames separated by comma. e.g `usernames=alice,bob` */
                usernames?: string;
                /** @description slug of the user's organization if he is in one, orgId is not required if using this parameter */
                orgSlug?: string;
                /** @description ID of the organization of the user you want the get the event-types of, orgSlug is not needed when using this parameter */
                orgId?: number;
            };
            header: {
                /** @description Must be set to 2024-06-14 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetEventTypesOutput_2024_06_14"];
                };
            };
        };
    };
    EventTypesController_2024_06_14_createEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-06-14 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateEventTypeOutput_2024_06_14"];
                };
            };
        };
    };
    EventTypesController_2024_06_14_getEventTypeById: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-06-14 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetEventTypeOutput_2024_06_14"];
                };
            };
        };
    };
    EventTypesController_2024_06_14_deleteEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-06-14 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteEventTypeOutput_2024_06_14"];
                };
            };
        };
    };
    EventTypesController_2024_06_14_updateEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-06-14 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateEventTypeOutput_2024_06_14"];
                };
            };
        };
    };
    EventTypeWebhooksController_getEventTypeWebhooks: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypeWebhooksOutputResponseDto"];
                };
            };
        };
    };
    EventTypeWebhooksController_createEventTypeWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypeWebhookOutputResponseDto"];
                };
            };
        };
    };
    EventTypeWebhooksController_deleteAllEventTypeWebhooks: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteManyWebhooksOutputResponseDto"];
                };
            };
        };
    };
    EventTypeWebhooksController_getEventTypeWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypeWebhookOutputResponseDto"];
                };
            };
        };
    };
    EventTypeWebhooksController_deleteEventTypeWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypeWebhookOutputResponseDto"];
                };
            };
        };
    };
    EventTypeWebhooksController_updateEventTypeWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWebhookInputDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventTypeWebhookOutputResponseDto"];
                };
            };
        };
    };
    OrganizationsOrganizationsController_getOrganizations: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
                /**
                 * @description The slug of the managed organization
                 * @example organization-slug
                 */
                slug?: string;
                /**
                 * @description The key of the metadata - it is case sensitive so provide exactly as stored. If you provide it then you must also provide metadataValue
                 * @example metadata-key
                 */
                metadataKey?: string;
                /**
                 * @description The value of the metadata - it is case sensitive so provide exactly as stored. If you provide it then you must also provide metadataKey
                 * @example metadata-value
                 */
                metadataValue?: string;
            };
            header?: {
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedOrganizationsOutput"];
                };
            };
        };
    };
    OrganizationsOrganizationsController_createOrganization: {
        parameters: {
            query?: never;
            header?: {
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOrganizationInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateManagedOrganizationOutput"];
                };
            };
        };
    };
    OrganizationsOrganizationsController_getOrganization: {
        parameters: {
            query?: never;
            header?: {
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                managedOrganizationId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedOrganizationOutput"];
                };
            };
        };
    };
    OrganizationsOrganizationsController_deleteOrganization: {
        parameters: {
            query?: never;
            header?: {
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                managedOrganizationId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedOrganizationOutput"];
                };
            };
        };
    };
    OrganizationsOrganizationsController_updateOrganization: {
        parameters: {
            query?: never;
            header?: {
                /** @description For platform customers - OAuth client secret key */
                "x-cal-secret-key"?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path: {
                orgId: number;
                managedOrganizationId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrganizationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetManagedOrganizationOutput"];
                };
            };
        };
    };
    MeController_getMe: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetMeOutput"];
                };
            };
        };
    };
    MeController_updateMe: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateManagedUserInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateMeOutput"];
                };
            };
        };
    };
    OAuthClientsController_getOAuthClients: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOAuthClientsResponseDto"];
                };
            };
        };
    };
    OAuthClientsController_createOAuthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOAuthClientInput"];
            };
        };
        responses: {
            /** @description Create an OAuth client */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateOAuthClientResponseDto"];
                };
            };
        };
    };
    OAuthClientsController_getOAuthClientById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOAuthClientResponseDto"];
                };
            };
        };
    };
    OAuthClientsController_deleteOAuthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOAuthClientResponseDto"];
                };
            };
        };
    };
    OAuthClientsController_updateOAuthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOAuthClientInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetOAuthClientResponseDto"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_requestEmailVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestEmailVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestEmailVerificationOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_requestPhoneVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestPhoneVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestPhoneVerificationOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_verifyEmail: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyEmailInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_verifyPhoneNumber: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyPhoneInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhoneOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_getVerifiedEmails: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailsOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_getVerifiedPhoneNumbers: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhonesOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_getVerifiedEmailById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                id: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailOutput"];
                };
            };
        };
    };
    OrgTeamsVerifiedResourcesController_getVerifiedPhoneById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhoneOutput"];
                };
            };
        };
    };
    RoutingFormsController_calculateSlotsBasedOnRoutingFormResponse: {
        parameters: {
            query: {
                /**
                 * @description
                 *           Time starting from which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to start of day or specify hours:
                 *           2024-08-13 (will have hours 00:00:00 aka at very beginning of the date) or you can specify hours manually like 2024-08-13T09:00:00Z
                 *
                 * @example 2050-09-05
                 */
                start: string;
                /**
                 * @description
                 *           Time until which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to end of day or specify hours:
                 *           2024-08-20 (will have hours 23:59:59 aka at the very end of the date) or you can specify hours manually like 2024-08-20T18:00:00Z
                 * @example 2050-09-06
                 */
                end: string;
                /**
                 * @description Time zone in which the available slots should be returned. Defaults to UTC.
                 * @example Europe/Rome
                 */
                timeZone?: string;
                /**
                 * @description If event type has multiple possible durations then you can specify the desired duration here. Also, if you are fetching slots for a dynamic event then you can specify the duration her which defaults to 30, meaning that returned slots will be each 30 minutes long.
                 * @example 60
                 */
                duration?: number;
                /**
                 * @description Format of slot times in response. Use 'range' to get start and end times.
                 * @example range
                 */
                format?: "range" | "time";
                /**
                 * @description The unique identifier of the booking being rescheduled. When provided will ensure that the original booking time appears within the returned available slots when rescheduling.
                 * @example abc123def456
                 */
                bookingUidToReschedule?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                routingFormId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResponseSlotsOutput"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_getSchedules: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSchedulesOutput_2024_06_11"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_createSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateScheduleInput_2024_06_11"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_getDefaultSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetDefaultScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_getSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path: {
                scheduleId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_deleteSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path: {
                scheduleId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    SchedulesController_2024_06_11_updateSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
                /** @description Must be set to 2024-06-11 */
                "cal-api-version": string;
            };
            path: {
                scheduleId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateScheduleInput_2024_06_11"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateScheduleOutput_2024_06_11"];
                };
            };
        };
    };
    SelectedCalendarsController_addSelectedCalendar: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SelectedCalendarsInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SelectedCalendarOutputResponseDto"];
                };
            };
        };
    };
    SelectedCalendarsController_deleteSelectedCalendar: {
        parameters: {
            query: {
                integration: string;
                externalId: string;
                credentialId: string;
                delegationCredentialId?: string;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SelectedCalendarOutputResponseDto"];
                };
            };
        };
    };
    SlotsController_2024_09_04_getAvailableSlots: {
        parameters: {
            query: {
                /**
                 * @description The unique identifier of the booking being rescheduled. When provided will ensure that the original booking time appears within the returned available slots when rescheduling.
                 * @example abc123def456
                 */
                bookingUidToReschedule?: unknown;
                /**
                 * @description
                 *           Time starting from which available slots should be checked.
                 *
                 *           Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *           You can pass date without hours which defaults to start of day or specify hours:
                 *           2024-08-13 (will have hours 00:00:00 aka at very beginning of the date) or you can specify hours manually like 2024-08-13T09:00:00Z.
                 * @example 2050-09-05
                 */
                start: unknown;
                /**
                 * @description
                 *         Time until which available slots should be checked.
                 *
                 *         Must be in UTC timezone as ISO 8601 datestring.
                 *
                 *         You can pass date without hours which defaults to end of day or specify hours:
                 *         2024-08-20 (will have hours 23:59:59 aka at the very end of the date) or you can specify hours manually like 2024-08-20T18:00:00Z.
                 * @example 2050-09-06
                 */
                end: unknown;
                /**
                 * @description The slug of the organization to which user with username belongs or team with teamSlug belongs.
                 * @example org-slug
                 */
                organizationSlug?: unknown;
                /**
                 * @description The slug of the team who owns event type with eventTypeSlug - used when slots are checked for team event type.
                 * @example team-slug
                 */
                teamSlug?: unknown;
                /**
                 * @description The username of the user who owns event type with eventTypeSlug - used when slots are checked for individual user event type.
                 * @example bob
                 */
                username?: unknown;
                /**
                 * @description The slug of the event type for which available slots should be checked. If slug is provided then username or teamSlug must be provided too and if relevant organizationSlug too.
                 * @example event-type-slug
                 */
                eventTypeSlug?: unknown;
                /**
                 * @description The ID of the event type for which available slots should be checked.
                 * @example 100
                 */
                eventTypeId?: unknown;
                /**
                 * @description The usernames for which available slots should be checked separated by a comma.
                 *
                 *         Checking slots by usernames is used mainly for dynamic events where there is no specific event but we just want to know when 2 or more people are available.
                 *
                 *         Must contain at least 2 usernames.
                 * @example alice,bob
                 */
                usernames?: unknown;
                /**
                 * @description Format of slot times in response. Use 'range' to get start and end times. Use 'time' or omit this query parameter to get only start time.
                 * @example range
                 */
                format?: unknown;
                /**
                 * @description If event type has multiple possible durations then you can specify the desired duration here. Also, if you are fetching slots for a dynamic event then you can specify the duration her which defaults to 30, meaning that returned slots will be each 30 minutes long.
                 * @example 60
                 */
                duration?: unknown;
                /**
                 * @description Time zone in which the available slots should be returned. Defaults to UTC.
                 * @example Europe/Rome
                 */
                timeZone?: unknown;
            };
            header: {
                /** @description Must be set to 2024-09-04 */
                "cal-api-version": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A map of available slots indexed by date, where each date is associated with an array of time slots. If format=range is specified, each slot will be an object with start and end properties denoting start and end of the slot.
             *           For seated slots each object will have attendeesCount and bookingUid properties. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string[];
                    } | {
                        [key: string]: {
                            start?: string;
                            end?: string;
                        }[];
                    };
                };
            };
        };
    };
    SlotsController_2024_09_04_reserveSlot: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-09-04 */
                "cal-api-version": string;
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization?: string;
                /** @description For platform customers - OAuth client ID */
                "x-cal-client-id"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReserveSlotInput_2024_09_04"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReserveSlotOutputResponse_2024_09_04"];
                };
            };
        };
    };
    SlotsController_2024_09_04_getReservedSlot: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-09-04 */
                "cal-api-version": string;
            };
            path: {
                uid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetReservedSlotOutput_2024_09_04"];
                };
            };
        };
    };
    SlotsController_2024_09_04_deleteReservedSlot: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-09-04 */
                "cal-api-version": string;
            };
            path: {
                uid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    SlotsController_2024_09_04_updateReservedSlot: {
        parameters: {
            query?: never;
            header: {
                /** @description Must be set to 2024-09-04 */
                "cal-api-version": string;
            };
            path: {
                uid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReserveSlotInput_2024_09_04"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReserveSlotOutputResponse_2024_09_04"];
                };
            };
        };
    };
    StripeController_redirect: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripConnectOutputResponseDto"];
                };
            };
        };
    };
    StripeController_save: {
        parameters: {
            query: {
                state: string;
                code: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripCredentialsSaveOutputResponseDto"];
                };
            };
        };
    };
    StripeController_check: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StripCredentialsCheckOutputResponseDto"];
                };
            };
        };
    };
    TeamsController_getTeams: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamsOutput"];
                };
            };
        };
    };
    TeamsController_createTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTeamInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateTeamOutput"];
                };
            };
        };
    };
    TeamsController_getTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamOutput"];
                };
            };
        };
    };
    TeamsController_deleteTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrgTeamOutputResponseDto"];
                };
            };
        };
    };
    TeamsController_updateTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOrgTeamDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateTeamOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_getTeamEventTypes: {
        parameters: {
            query?: {
                /** @description Slug of team event type to return. */
                eventSlug?: string;
                /** @description Specifies the maximum number of hosts to include in the response. This limit helps optimize performance. If not provided, all Hosts will be fetched. */
                hostsLimit?: number;
            };
            header?: never;
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamEventTypesOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_createTeamEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTeamEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateTeamEventTypeOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_getTeamEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamEventTypeOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_deleteTeamEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteTeamEventTypeOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_updateTeamEventType: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                eventTypeId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTeamEventTypeInput_2024_06_14"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateTeamEventTypeOutput"];
                };
            };
        };
    };
    TeamsEventTypesController_createPhoneCall: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                eventTypeId: number;
                orgId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePhoneCallInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreatePhoneCallOutput"];
                };
            };
        };
    };
    TeamsMembershipsController_getTeamMemberships: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamMembershipsOutput"];
                };
            };
        };
    };
    TeamsMembershipsController_createTeamMembership: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTeamMembershipInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateTeamMembershipOutput"];
                };
            };
        };
    };
    TeamsMembershipsController_getTeamMembership: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetTeamMembershipOutput"];
                };
            };
        };
    };
    TeamsMembershipsController_deleteTeamMembership: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteTeamMembershipOutput"];
                };
            };
        };
    };
    TeamsMembershipsController_updateTeamMembership: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                teamId: number;
                membershipId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTeamMembershipInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UpdateTeamMembershipOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_requestEmailVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestEmailVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestEmailVerificationOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_requestPhoneVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestPhoneVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestPhoneVerificationOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_verifyEmail: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyEmailInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_verifyPhoneNumber: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyPhoneInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhoneOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_getVerifiedEmails: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailsOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_getVerifiedPhoneNumbers: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhonesOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_getVerifiedEmailById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                id: number;
                teamId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedEmailOutput"];
                };
            };
        };
    };
    TeamsVerifiedResourcesController_getVerifiedPhoneById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                teamId: number;
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeamVerifiedPhoneOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_requestEmailVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestEmailVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestEmailVerificationOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_requestPhoneVerificationCode: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestPhoneVerificationInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestPhoneVerificationOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_verifyEmail: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyEmailInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedEmailOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_verifyPhoneNumber: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyPhoneInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedPhoneOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_getVerifiedEmails: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedEmailsOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_getVerifiedPhoneNumbers: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedPhonesOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_getVerifiedEmailById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedEmailOutput"];
                };
            };
        };
    };
    UserVerifiedResourcesController_getVerifiedPhoneById: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ or managed user access token */
                Authorization: string;
            };
            path: {
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserVerifiedPhoneOutput"];
                };
            };
        };
    };
    WebhooksController_getWebhooks: {
        parameters: {
            query?: {
                /**
                 * @description Maximum number of items to return
                 * @example 25
                 */
                take?: number;
                /**
                 * @description Number of items to skip
                 * @example 0
                 */
                skip?: number;
            };
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserWebhooksOutputResponseDto"];
                };
            };
        };
    };
    WebhooksController_createWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateWebhookInputDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserWebhookOutputResponseDto"];
                };
            };
        };
    };
    WebhooksController_getWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserWebhookOutputResponseDto"];
                };
            };
        };
    };
    WebhooksController_deleteWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserWebhookOutputResponseDto"];
                };
            };
        };
    };
    WebhooksController_updateWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description value must be `Bearer <token>` where `<token>` is api key prefixed with cal_ */
                Authorization: string;
            };
            path: {
                webhookId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateWebhookInputDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserWebhookOutputResponseDto"];
                };
            };
        };
    };
}
